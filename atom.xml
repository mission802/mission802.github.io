<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AtomPi&#39;s Blog</title>
  
  <subtitle>HELLO WORLD</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.atompi.com/"/>
  <updated>2021-02-23T13:43:20.505Z</updated>
  <id>https://blog.atompi.com/</id>
  
  <author>
    <name>atompi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 CoreDNS 作为数据中心内网 DNS 服务器</title>
    <link href="https://blog.atompi.com/2020/08/03/%E4%BD%BF%E7%94%A8%20CoreDNS%20%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%86%85%E7%BD%91%20DNS%20%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://blog.atompi.com/2020/08/03/%E4%BD%BF%E7%94%A8%20CoreDNS%20%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%86%85%E7%BD%91%20DNS%20%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-08-03T06:54:12.000Z</published>
    <updated>2021-02-23T13:43:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建配置文件持久化目录，并复制配置文件"><a href="#创建配置文件持久化目录，并复制配置文件" class="headerlink" title="创建配置文件持久化目录，并复制配置文件"></a>创建配置文件持久化目录，并复制配置文件</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/coredns/zones</span><br><span class="line">cp hosts /data/coredns/</span><br><span class="line"># 以添加 zone atompi.cc 为例：</span><br><span class="line">mkdir -p /data/coredns/zones/atompi.cc</span><br><span class="line">cp db.atompi.cc /data/coredns/zones/atompi.cc/</span><br><span class="line">cp Corefile /data/coredns/</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>各配置文件示例：</p><ul><li><code>Corefile</code></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.:53 {</span><br><span class="line">    forward . 223.5.5.5 223.6.6.6</span><br><span class="line">    reload 10s</span><br><span class="line">    loop</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache 30</span><br><span class="line"></span><br><span class="line">    hosts /data/hosts {</span><br><span class="line">        ttl 10</span><br><span class="line">        reload 10s</span><br><span class="line">        no_reverse</span><br><span class="line">        fallthrough</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">atompi.cc {</span><br><span class="line">    forward . 223.5.5.5 223.6.6.6</span><br><span class="line">    loop</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache 30</span><br><span class="line"></span><br><span class="line">    auto {</span><br><span class="line">        directory /data/zones/atompi.cc</span><br><span class="line">        reload 10s</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>hosts</code></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2 www.test.com</span><br></pre></td></tr></tbody></table></figure><ul><li><code>db.atompi.cc</code></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$TTL 3600</span><br><span class="line">$ORIGIN atompi.cc.</span><br><span class="line"></span><br><span class="line">@ IN SOA ns1.atompi.cc. atompi.atompi.cc. (</span><br><span class="line">    2020072410 ; Serial</span><br><span class="line">    1H         ; Refresh</span><br><span class="line">    600        ; Retry</span><br><span class="line">    7D         ; Expire</span><br><span class="line">    600        ; Negative Cache TTL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">@ IN NS ns1</span><br><span class="line"></span><br><span class="line">ns1 IN A 192.168.1.2</span><br><span class="line"></span><br><span class="line">; Custome</span><br><span class="line">@                 IN A     192.168.1.2</span><br><span class="line">*                 IN CNAME @</span><br><span class="line">kube-apiserver    IN A     192.168.1.3</span><br><span class="line">kube-dashboard    IN A     192.168.1.4</span><br><span class="line">hub               IN A     192.168.1.5</span><br></pre></td></tr></tbody></table></figure><ul><li><code>docker-compose-host-network.yml</code></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: "3.3"</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  coredns:</span><br><span class="line">    image: coredns/coredns:1.7.0</span><br><span class="line">    command: -conf /data/Corefile</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/coredns:/data:ro</span><br><span class="line">    cap_drop:</span><br><span class="line">      - ALL</span><br><span class="line">    cap_add:</span><br><span class="line">      - NET_BIND_SERVICE</span><br><span class="line">    read_only: true</span><br><span class="line">    restart: on-failure</span><br><span class="line">    network_mode: host</span><br><span class="line">    logging:</span><br><span class="line">      driver: "json-file"</span><br><span class="line">      options:</span><br><span class="line">        max-size: "100m"</span><br><span class="line">        max-file: "10"</span><br></pre></td></tr></tbody></table></figure><ul><li><code>docker-compose.yml</code></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">version: "3.3"</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  coredns:</span><br><span class="line">    image: coredns/coredns:1.7.0</span><br><span class="line">    command: -conf /data/Corefile</span><br><span class="line">    ports:</span><br><span class="line">      - "53:53/udp"</span><br><span class="line">      - "53:53/tcp"</span><br><span class="line">      - "9153:9153/tcp"</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/coredns:/data:ro</span><br><span class="line">    cap_drop:</span><br><span class="line">      - ALL</span><br><span class="line">    cap_add:</span><br><span class="line">      - NET_BIND_SERVICE</span><br><span class="line">    read_only: true</span><br><span class="line">    restart: on-failure</span><br><span class="line">    logging:</span><br><span class="line">      driver: "json-file"</span><br><span class="line">      options:</span><br><span class="line">        max-size: "100m"</span><br><span class="line">        max-file: "10"</span><br></pre></td></tr></tbody></table></figure><h2 id="使用-docker-compose-启动服务"><a href="#使用-docker-compose-启动服务" class="headerlink" title="使用 docker-compose 启动服务"></a>使用 docker-compose 启动服务</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"># host network 模式，解决 CentOS 下 bridge 网络无法被同节点其他容器连接</span><br><span class="line">docker-compose -f docker-compose-host-network.yml up -d</span><br></pre></td></tr></tbody></table></figure><h2 id="PS1-更新-RFC-1035-style-zone-文件记录"><a href="#PS1-更新-RFC-1035-style-zone-文件记录" class="headerlink" title="PS1: 更新 RFC 1035-style zone 文件记录"></a>PS1: 更新 RFC 1035-style zone 文件记录</h2><p>对于 <code>hosts</code> 文件的更新会在 3 秒内更新解析值</p><p>对于 <code>auto</code> 插件指定的 RFC 1035-style zone 文件的更新，<a href="https://coredns.io/plugins/auto/#syntax" target="_blank" rel="noopener">官方文档</a>给出： <code>auto</code> 插件会在 <code>reload</code> 指定的时间重新读取 zone 文件，并且在 Serial 值更新是重新加载 zone 文件，只修改记录而不修改 Serial 值是无法应用更新的。</p><h2 id="PS2-zone-文件命名规则（必须遵从）"><a href="#PS2-zone-文件命名规则（必须遵从）" class="headerlink" title="PS2: zone 文件命名规则（必须遵从）"></a>PS2: zone 文件命名规则（必须遵从）</h2><p>CoreDNS 根据“域”来分发解析请求到指定配置，所以必须匹配指定的域才能获取到正确的解析。 <code>auto</code> 插件在读取 <code>directory</code> 指定的 zone 目录时会根据正则表达式解析 zone 文件名（详见<a href="https://coredns.io/plugins/auto/#syntax" target="_blank" rel="noopener">官方说明</a>），默认规则为： <code>db\.(.*) {1}</code> i.e. 如果文件名为 <code>db.example.com</code> ， 那么解析到的域就是 <code>example.com</code> 。</p><p>同时 <code>Corefile</code> 文件中需要为每一个自定义域新建一组配置，如 <code>atompi.cc</code> 域：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">atompi.cc {</span><br><span class="line">    forward . 223.5.5.5 223.6.6.6</span><br><span class="line">    loop</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache 30</span><br><span class="line"></span><br><span class="line">    auto {</span><br><span class="line">        directory /data/zones/atompi.cc</span><br><span class="line">        reload 10s</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建配置文件持久化目录，并复制配置文件&quot;&gt;&lt;a href=&quot;#创建配置文件持久化目录，并复制配置文件&quot; class=&quot;headerlink&quot; title=&quot;创建配置文件持久化目录，并复制配置文件&quot;&gt;&lt;/a&gt;创建配置文件持久化目录，并复制配置文件&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir -p /data/coredns/zones&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp hosts /data/coredns/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 以添加 zone atompi.cc 为例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir -p /data/coredns/zones/atompi.cc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp db.atompi.cc /data/coredns/zones/atompi.cc/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp Corefile /data/coredns/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="CoreDNS" scheme="https://blog.atompi.com/categories/CoreDNS/"/>
    
    
      <category term="CoreDNS" scheme="https://blog.atompi.com/tags/CoreDNS/"/>
    
      <category term="Cloud Nativa" scheme="https://blog.atompi.com/tags/Cloud-Nativa/"/>
    
      <category term="DNS" scheme="https://blog.atompi.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>离线安装 Harbor v2</title>
    <link href="https://blog.atompi.com/2020/08/03/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%20Harbor%20v2/"/>
    <id>https://blog.atompi.com/2020/08/03/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%20Harbor%20v2/</id>
    <published>2020-08-03T06:45:41.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-harbor-？"><a href="#什么是-harbor-？" class="headerlink" title="什么是 harbor ？"></a>什么是 harbor ？</h2><div align="center"><img width="100%" src="/images/harbor_logo.png"></div><p>Harbor 是一个开源、可信、云原生的镜像仓库项目，用于存储，签名和扫描内容。</p><p>Harbor 通过添加用户通常需要的功能（如安全性，身份验证和管理）来扩展开源 Docker 镜像分发工具（如 Docker registry ）。</p><p>Harbor 使 registry 更接近构建和运行环境，并且可以提高镜像传输效率。</p><p>Harbor 支持在 registry 之间复制映像，还提供高级安全功能，如用户管理，访问控制和活动审计。</p><a id="more"></a><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>基于角色的访问控制：用户和存储库通过“项目”进行组织，用户可以对项目下的镜像赋予不同的权限。</li><li>基于策略的镜像复制：可以在多个 registry 实例之间复制（同步）映像，并自动重试错误。非常适合负载平衡，高可用性，多数据中心，混合和多云场景。</li><li>漏洞扫描： Harbor 定期扫描镜像并警告用户漏洞。</li><li>LDAP / AD 支持：Harbor 与现有企业 LDAP / AD 集成，用于用户身份验证和管理。</li><li>镜像删除和垃圾收集：可以删除镜像，并可以回收它们的空间。</li><li>公证：可以确保图像的真实性。</li><li>图形化界面：用户可以轻松浏览，搜索存储库和管理项目。</li><li>审计：跟踪存储库的所有操作。</li><li>RESTful API ：适用于大多数管理操作的 RESTful API ，易于与外部系统集成。</li><li>易于部署：提供在线和离线安装程序。</li><li>支持 Helm 包管理</li></ul><h2 id="部署-amp-运行"><a href="#部署-amp-运行" class="headerlink" title="部署 & 运行"></a>部署 & 运行</h2><h3 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h3><p>目前只支持在 Linux 操作系统下部署， 安装最新版本的 docker 及 docker-compose ，最低版本要求如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Docker engine: Version 17.06.0-ce+ or higher</span><br><span class="line">Docker Compose: Version 1.18.0 or higher</span><br></pre></td></tr></tbody></table></figure><p>同时需要开放如下端口：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80: HTTP</span><br><span class="line">443: HTTPS</span><br></pre></td></tr></tbody></table></figure><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><ul><li>下载离线安装程序</li></ul><p>下载地址： <code>https://github.com/vmware/harbor/releases</code></p><p>选择： <code>harbor-offline-installer-<version>.tgz</code></p><ul><li>压安装包</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xf harbor-offline-installer-<version>.tgz</span><br></pre></td></tr></tbody></table></figure><ul><li>配置 Harbor</li></ul><p>配置文件模板为： <code>harbor.yml.tmpl</code></p><p>复制模板文件，并命名为 <code>harbor.yml</code></p><p>在 <code>harbor.yml</code> 中有两类参数：必需参数和可选参数。</p><ul><li>必选参数：需要在配置文件中设置这些参数。如果用户在 <code>harbor.yml</code> 中更新它们并运行 <code>install.sh</code> 脚本以重新安装 Harbor ，它们将生效。</li><li>可选参数：这些参数对于更新是可选的，即用户可以将它们保留为默认值，并在启动 Harbour 后在 Web UI 上更新它们。如果它们设置在 <code>harbor.yml</code> 中，它们只会在第一次启动 Harbour 时生效。后续在 Web UI 中的更新将忽略 <code>harbor.yml</code> 中这些参数。</li></ul><p><em>在这里，我只列出部分必选参数的配置，具体参数说明见文章末尾处给出的官方安装文档连接</em></p><ol><li>必选参数：</li></ol><ul><li><code>hostname</code>: 访问 harbor 的域名，可以使用主机 IP ，但建议使用域名</li></ul><p><code>hostname = reg.atompi.com</code></p><ul><li><code>http / https</code>: 访问 harbor 的 url 协议，若只使用 <code>http</code> ，则注释掉 <code>https</code> 项即可（如下），若启用 <code>https</code> 请参考 <a href="https://goharbor.io/docs/2.0.0/install-config/configure-https/" target="_blank" rel="noopener">Configuring Harbor with HTTPS Access</a></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># http related config</span><br><span class="line">http:</span><br><span class="line">  # port for http, default is 80. If https enabled, this port will redirect to https port</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line"># https related config</span><br><span class="line">#https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">  #port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">  #certificate: /your/certificate/path</span><br><span class="line">  #private_key: /your/private/key/path</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>harbor_admin_password</code>: 超级管理员用户 <code>admin</code> 的登录密码</p></li><li><p><code>database.password</code>: 数据库 root 用户密码，用于指定 Harbor 默认数据库 root 用户密码，生产环境建议修改这个值为复杂密码</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database:</span><br><span class="line">  # The password for the root user of Harbor DB. Change this before any production use.</span><br><span class="line">  password: root123</span><br></pre></td></tr></tbody></table></figure><ul><li><code>data_volume</code>: 由于 Harbor 所有组件都使用 docker 容器化部署，所以需要将容器数据持久化到宿主机目录，该配置项就是指定持久化目录的挂载点，建议在某目录下创建 <code>harbor</code> 文件夹，并作为挂载点，便于统一管理和迁移。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_volume: /data/harbor</span><br></pre></td></tr></tbody></table></figure><h3 id="执行-install-sh-开始安装"><a href="#执行-install-sh-开始安装" class="headerlink" title="执行 install.sh 开始安装"></a>执行 install.sh 开始安装</h3><p>默认情况下，不带任何参数的 <code>install.sh</code> 脚本只安装 Harbor 主服务，如果需要安装其他附加服务，可带指定参数安装，可安装的附加服务有：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Harbor with Notary （ --with-notary ）：一个允许任何人信任任意数据集合的项目，用于运行和与可信集合交互。</span><br><span class="line">Harbor with Clair （--with-clair）： Docker 镜像安全漏洞扫描工具</span><br><span class="line">Harbor with Chart Repository Service （--with-chartmuseum）： Helm 包管理工具</span><br></pre></td></tr></tbody></table></figure><p>这里我们安装带 Helm 包管理的 Harbor</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install.sh --with-chartmuseum</span><br></pre></td></tr></tbody></table></figure><h3 id="登录-harbor-并配置-Docker-“insecure-registries”"><a href="#登录-harbor-并配置-Docker-“insecure-registries”" class="headerlink" title="登录 harbor 并配置 Docker “insecure-registries”"></a>登录 harbor 并配置 Docker “insecure-registries”</h3><ul><li><p>Web UI 地址： <code>http://reg.atompi.com</code></p></li><li><p>docker login</p></li></ul><p>修改 docker daemon 配置文件 <code>/etc/docker/daemon.json</code> ，添加如下配置项：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "insecure-registries": ["reg.atompi.com"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>docker 登录 registry</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker login reg.atompi.com</span><br></pre></td></tr></tbody></table></figure><hr><ul><li><a href="https://goharbor.io/docs/2.0.0/install-config/" target="_blank" rel="noopener">官方安装文档</a></li><li><a href="https://goharbor.io/docs/2.0.0/administration/" target="_blank" rel="noopener">官方管理文档</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-harbor-？&quot;&gt;&lt;a href=&quot;#什么是-harbor-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 harbor ？&quot;&gt;&lt;/a&gt;什么是 harbor ？&lt;/h2&gt;&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;/images/harbor_logo.png&quot;&gt;&lt;/div&gt;

&lt;p&gt;Harbor 是一个开源、可信、云原生的镜像仓库项目，用于存储，签名和扫描内容。&lt;/p&gt;
&lt;p&gt;Harbor 通过添加用户通常需要的功能（如安全性，身份验证和管理）来扩展开源 Docker 镜像分发工具（如 Docker registry ）。&lt;/p&gt;
&lt;p&gt;Harbor 使 registry 更接近构建和运行环境，并且可以提高镜像传输效率。&lt;/p&gt;
&lt;p&gt;Harbor 支持在 registry 之间复制映像，还提供高级安全功能，如用户管理，访问控制和活动审计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Harbor" scheme="https://blog.atompi.com/categories/Harbor/"/>
    
    
      <category term="Docker" scheme="https://blog.atompi.com/tags/Docker/"/>
    
      <category term="Harbor" scheme="https://blog.atompi.com/tags/Harbor/"/>
    
      <category term="Cloud Native" scheme="https://blog.atompi.com/tags/Cloud-Native/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose 安装 Jenkins</title>
    <link href="https://blog.atompi.com/2020/08/03/Docker%20Compose%20%E5%AE%89%E8%A3%85%20Jenkins/"/>
    <id>https://blog.atompi.com/2020/08/03/Docker%20Compose%20%E5%AE%89%E8%A3%85%20Jenkins/</id>
    <published>2020-08-03T06:44:46.000Z</published>
    <updated>2021-02-23T13:43:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h2><p>前往 <code>https://github.com/docker/compose/releases</code> 下载对应的 docker-compose 二进制可执行文件</p><p>将 docker-compose 移动至 <code>/usr/local/bin/</code> 目录下，并赋予可执行权限</p><h2 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jenkins/jenkins:lts</span><br><span class="line">nginx:1.16.1</span><br><span class="line">docker:19.03.12-dind</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h2 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h2><p>为了持久化 CI 数据，我们需要将 jenkins 部分目录挂载到宿主机保存，如在 <code>/data</code> 目录下创建如下目录：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/atompi-ci/jenkins</span><br><span class="line">chown -R 1000:1000 /data/atompi-ci/jenkins</span><br><span class="line">mkdir -p /data/atompi-ci/nginx/conf.d</span><br><span class="line">mkdir -p /data/atompi-ci/nginx/logs</span><br><span class="line">mkdir -p /data/atompi-ci/nginx/ssl</span><br><span class="line">mkdir -p /data/atompi-ci/docker/data</span><br><span class="line">mkdir -p /data/atompi-ci/docker/etc</span><br></pre></td></tr></tbody></table></figure><p><em>PS: 由于 jenkins images 在 使用 Dockerfile 构建时，默认 UID 为 1000 ，所以在挂载 jenkins home 目录时需要将宿主机目录 UID 设置为 1000 ，或者修改 docker-compose.yml 将 jenkins 容器用户修改为 root ，这里使用了修改 docker-compose.yml 的方式，出于安全考虑，建议修改宿主机目录 UID ，如： <code>chown -R 1000:1000 /data/atompi-ci/jenkins</code></em></p><h2 id="使用-docker-compose-部署-jenkins"><a href="#使用-docker-compose-部署-jenkins" class="headerlink" title="使用 docker-compose 部署 jenkins"></a>使用 docker-compose 部署 jenkins</h2><p>创建 <code>~/atompi-ci/</code> 目录并创建 <code>docker-compose.yml</code> 文件，文件内容如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: '3.8'</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:lts</span><br><span class="line">    environment:</span><br><span class="line">      - JAVA_OPTS=-Duser.timezone=Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/atompi-ci/jenkins:/var/jenkins_home</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:1.16.1</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/atompi-ci/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">      - /data/atompi-ci/nginx/logs:/var/log/nginx</span><br><span class="line">      - /data/atompi-ci/nginx/ssl:/etc/nginx/ssl</span><br><span class="line">  docker:</span><br><span class="line">    image: docker:19.03.12-dind</span><br><span class="line">    privileged: true</span><br><span class="line">    environment:</span><br><span class="line">      - DOCKER_TLS_CERTDIR=</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/atompi-ci/docker/data:/var/lib/docker</span><br><span class="line">      - /data/atompi-ci/docker/etc:/etc/docker</span><br></pre></td></tr></tbody></table></figure><p>创建 <code>/data/atompi-ci/nginx/conf.d/jenkins.conf</code> 文件，该文件为 Jenkins 的 Nginx 反向代理配置文件，如果不需要同时安装 Nginx 可以跳过，并注释掉 <code>docker-compose.yml</code> 中的 nginx 部分，文件内容如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_size 0;</span><br><span class="line">upstream jenkins {</span><br><span class="line">  keepalive 32; # keepalive connections</span><br><span class="line">  server jenkins:8080; # jenkins ip and port</span><br><span class="line">}</span><br><span class="line">server {</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ci.atompi.cc;</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        proxy_pass http://jenkins;</span><br><span class="line">        proxy_redirect $scheme://ci.atompi.cc $scheme://ci.atompi.com:8888;</span><br><span class="line">        proxy_read_timeout 90;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html {</span><br><span class="line">        root html;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行部署命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></tbody></table></figure><h2 id="配置-jenkins"><a href="#配置-jenkins" class="headerlink" title="配置 jenkins"></a>配置 jenkins</h2><p>初始化 jenkins</p><p>浏览器打开我们在 nginx 配置文件中设置的域名，如: <a href="http://ci.atompi.cc" target="_blank" rel="noopener">http://ci.atompi.cc</a></p><div align="center"><img width="100%" src="/images/jenkins01.png"></div><p>查看初始密码，在 jenkins 目录下 使用 docker-compose 命令查看 jenkins 日志，或者进入 jenkins 容器查看文件： <code>/var/jenkins_home/secrets/initialAdminPassword</code> （注意：初始化完成后，这个文件会消失）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看日志</span><br><span class="line"># docker-compose logs jenkins</span><br><span class="line"># 进入容器</span><br><span class="line"># docker-compose exec jenkins bash</span><br><span class="line"># cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></tbody></table></figure><div align="center"><img width="100%" src="/images/jenkins02.png"></div><p>输入初始密码后进入插件安装界面，我们选择“安装推荐插件”。</p><div align="center"><img width="100%" src="/images/jenkins03.png"></div><p>去喝杯茶？</p><div align="center"><img width="100%" src="/images/jenkins04.png"></div><p>插件安装完成后，创建第一个管理员用户</p><div align="center"><img width="100%" src="/images/jenkins05.png"></div><p>选择保存并完成，之后进入确认 Jenkins URL 页面</p><div align="center"><img width="100%" src="/images/jenkins06.png"></div><p>初始化完成，开始使用 jenkins</p><div align="center"><img width="100%" src="/images/jenkins07.png"></div><p>进入 jenkins 首页</p><div align="center"><img width="100%" src="/images/jenkins08.png"></div><h2 id="安装-Gitee-Jenkins-Plugin"><a href="#安装-Gitee-Jenkins-Plugin" class="headerlink" title="安装 Gitee Jenkins Plugin"></a>安装 Gitee Jenkins Plugin</h2><ol><li>在线安装</li></ol><p>管理员登录 jenkins ，进入： 系统管理 –> 管理插件 –> 可选插件，在插件搜索栏输入“ Gitee ”，即可在下方可选列表中勾选“ Gitee ”。选择“下载待重启后安装”即可在重启 Jenkins 后完成安装。</p><div align="center"><img width="100%" src="/images/jenkins09.png"></div><ol start="2"><li>上传插件 hpi 文件安装</li></ol><p>从 <a href="https://gitee.com/oschina/Gitee-Jenkins-Plugin/releases" target="_blank" rel="noopener">release</a> 列表中进入最新发行版，下载对应的 <code>gitee-<version>.hpi</code> 文件</p><p>进入：系统管理 –> 管理插件 –> 高级，在“上传插件”处上传 hpi 文件</p><div align="center"><img width="100%" src="/images/jenkins10.png"></div><ul><li><a href="https://gitee.com/oschina/Gitee-Jenkins-Plugin#%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">Gitee Jenkins Plugin 使用文档</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装-docker-compose&quot;&gt;&lt;a href=&quot;#安装-docker-compose&quot; class=&quot;headerlink&quot; title=&quot;安装 docker-compose&quot;&gt;&lt;/a&gt;安装 docker-compose&lt;/h2&gt;&lt;p&gt;前往 &lt;code&gt;https://github.com/docker/compose/releases&lt;/code&gt; 下载对应的 docker-compose 二进制可执行文件&lt;/p&gt;
&lt;p&gt;将 docker-compose 移动至 &lt;code&gt;/usr/local/bin/&lt;/code&gt; 目录下，并赋予可执行权限&lt;/p&gt;
&lt;h2 id=&quot;镜像列表&quot;&gt;&lt;a href=&quot;#镜像列表&quot; class=&quot;headerlink&quot; title=&quot;镜像列表&quot;&gt;&lt;/a&gt;镜像列表&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jenkins/jenkins:lts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nginx:1.16.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker:19.03.12-dind&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="https://blog.atompi.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.atompi.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>我应该使用哪个 Kubernetes apiVersion</title>
    <link href="https://blog.atompi.com/2019/12/10/%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAKubernetes_apiVersion/"/>
    <id>https://blog.atompi.com/2019/12/10/%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAKubernetes_apiVersion/</id>
    <published>2019-12-10T05:08:11.000Z</published>
    <updated>2021-02-23T13:43:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>Kubernetes 中的对象定义需要 <code>apiVersion</code> 字段。当 Kubernetes 发布（更改其 API 中的某些内容）发行版更新时，将创建一个新的 <code>apiVersion</code> 。但是，官方的 Kubernetes 文档几乎没有提供关于 <code>apiVersion</code> 的指导。本指南提供了要使用的版本的备忘单，同时介绍了每个版本及其发行时间表。</p><p><strong>PS</strong>：<em>只列出 v1.10+ 版本</em></p><a id="more"></a><h2 id="1-kind-apiVersion-对应表"><a href="#1-kind-apiVersion-对应表" class="headerlink" title="1. kind apiVersion 对应表"></a>1. kind apiVersion 对应表</h2><table><thead><tr><th>kind</th><th>apiVersion</th></tr></thead><tbody><tr><td>CertificateSigningRequest</td><td>certificates.k8s.io/v1beta1</td></tr><tr><td>ClusterRoleBinding</td><td>rbac.authorization.k8s.io/v1</td></tr><tr><td>ClusterRole</td><td>rbac.authorization.k8s.io/v1</td></tr><tr><td>ComponentStatus</td><td>v1</td></tr><tr><td>ConfigMap</td><td>v1</td></tr><tr><td>ControllerRevision</td><td>apps/v1</td></tr><tr><td>CronJob</td><td>batch/v1beta1</td></tr><tr><td>DaemonSet</td><td>apps/v1</td></tr><tr><td>Deployment</td><td>apps/v1</td></tr><tr><td>Endpoints</td><td>v1</td></tr><tr><td>Event</td><td>v1</td></tr><tr><td>HorizontalPodAutoscaler</td><td>autoscaling/v1</td></tr><tr><td>Ingress</td><td>networking.k8s.io/v1beta1</td></tr><tr><td>Job</td><td>batch/v1</td></tr><tr><td>LimitRange</td><td>v1</td></tr><tr><td>Namespace</td><td>v1</td></tr><tr><td>NetworkPolicy</td><td>networking.k8s.io/v1beta1</td></tr><tr><td>Node</td><td>v1</td></tr><tr><td>PersistentVolumeClaim</td><td>v1</td></tr><tr><td>PersistentVolume</td><td>v1</td></tr><tr><td>PodDisruptionBudget</td><td>policy/v1beta1</td></tr><tr><td>Pod</td><td>v1</td></tr><tr><td>PodSecurityPolicy</td><td>policy/v1beta1</td></tr><tr><td>PodTemplate</td><td>v1</td></tr><tr><td>ReplicaSet</td><td>apps/v1</td></tr><tr><td>ReplicationController</td><td>v1</td></tr><tr><td>ResourceQuota</td><td>v1</td></tr><tr><td>RoleBinding</td><td>rbac.authorization.k8s.io/v1</td></tr><tr><td>Role</td><td>rbac.authorization.k8s.io/v1</td></tr><tr><td>Secret</td><td>v1</td></tr><tr><td>ServiceAccount</td><td>v1</td></tr><tr><td>Service</td><td>v1</td></tr><tr><td>StatefulSet</td><td>apps/v1</td></tr></tbody></table><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-Overview&quot;&gt;&lt;a href=&quot;#0-Overview&quot; class=&quot;headerlink&quot; title=&quot;0. Overview&quot;&gt;&lt;/a&gt;0. Overview&lt;/h2&gt;&lt;p&gt;Kubernetes 中的对象定义需要 &lt;code&gt;apiVersion&lt;/code&gt; 字段。当 Kubernetes 发布（更改其 API 中的某些内容）发行版更新时，将创建一个新的 &lt;code&gt;apiVersion&lt;/code&gt; 。但是，官方的 Kubernetes 文档几乎没有提供关于 &lt;code&gt;apiVersion&lt;/code&gt; 的指导。本指南提供了要使用的版本的备忘单，同时介绍了每个版本及其发行时间表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;：&lt;em&gt;只列出 v1.10+ 版本&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://blog.atompi.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://blog.atompi.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>如何向使用 Go 开发的开源项目贡献代码</title>
    <link href="https://blog.atompi.com/2019/12/01/%E5%A6%82%E4%BD%95%E5%90%91%E4%BD%BF%E7%94%A8Go%E5%BC%80%E5%8F%91%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81/"/>
    <id>https://blog.atompi.com/2019/12/01/%E5%A6%82%E4%BD%95%E5%90%91%E4%BD%BF%E7%94%A8Go%E5%BC%80%E5%8F%91%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81/</id>
    <published>2019-12-01T08:09:28.000Z</published>
    <updated>2021-02-23T13:43:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>当我们要向一个开源项目贡献代码时通常的步骤是：</p><ol><li><p>fork 原项目到自己的账号上</p></li><li><p>在本地将 fork 的项目下载下来，开发，编译测试</p></li><li><p>本地检查没问题之后 push 到自己 fork 的仓库</p></li><li><p>按原项目贡献代码规范检查自己的代码以符合规范（一些热门的/专业社区维护的项目一般都有一套贡献规范，如 Kubernetes 、 moby （原 Docker ） 、 Go）</p></li><li><p>一切安排妥当后向原项目提交 PR 等待合并到原项目分支</p></li></ol><p>整个流程看起来十分简单，但这一套用在 Go 项目仿佛有点行不通了。</p><a id="more"></a><h2 id="1-遇到的问题"><a href="#1-遇到的问题" class="headerlink" title="1. 遇到的问题"></a>1. 遇到的问题</h2><p>我们在编写 Go 代码的时候通常会引用本项目或在其他项目的包，通常我们会使用远程地址指定：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    gitee.com/oscstudio/gitee-exporter/config</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>这时如果我们发现依赖的代码包中存在缺陷，或者我们有一个很棒的想法想要合并到源项目中，因此我们需要修改源项目的代码。于是我们按照上面的流程走一遍。</p><p>这时候问题来了：如果我们 fork 了源项目，然后通过 <code>go get</code> 拉取我们 fork 的代码时，会收到如下错误输出</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  blackbox_exporter proxy go get github.com/atompi/blackbox_exporter</span><br><span class="line"># github.com/atompi/blackbox_exporter</span><br><span class="line">src/github.com/atompi/blackbox_exporter/main.go:119:19: cannot use registry (type *"github.com/atompi/blackbox_exporter/vendor/github.com/prometheus/client_golang/prometheus".Registry) as type *"github.com/prometheus/blackbox_exporter/vendor/github.com/prometheus/client_golang/prometheus".Registry in argument to prober</span><br><span class="line">(base) ➜  blackbox_exporter</span><br></pre></td></tr></tbody></table></figure><p>如果此时我们修改代码中引用这个包的部分的代码，我们会修改到一些不必要（甚至不允许）修改的代码，导致我们的代码即使编译通过也无法合并到源项目。</p><p>还有一个问题，即 <a href="https://en.wikipedia.org/wiki/Dependency_hell" target="_blank" rel="noopener">Dependency hell</a> （依赖地狱）。依赖地狱是一个通俗的术语，用于体现使用了某些安装了依赖于其他特定版本的软件包的软件用户的沮丧心情。</p><p>Github 上不乏有这样的评论： <code>"When I run [the tests] they always pass, but that is because they import the package from [the package path] and not my local fork."</code> 。即：当我运行或者测试时，它们始终会通过，但这只是因为它们是从包源路径而非从我本地 fork 的包导入的。</p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p>为了避免上面遇到的问题，我们需要换一种方式来修改“ fork ”的代码</p><p>首先，我们在 Gitee 或者 Github 上 fork 我们需要贡献代码的项目，然后我们使用 <code>go get</code> 拉取源项目而非我们 fork 的项目，这样我们的代码 import 部分都是正确且不需要做不必要的修改的。</p><p>然后， <code>go get</code> 会将项目的 git 仓库拉到本地的 <code>$GOPATH/src</code> 目录下， <code>git remote -v</code> 可以看到，远程地址为源项目的地址，此时我们可以通过 <code>git remote add fork xxxx</code> 命令添加我们 fork 的仓库地址，让当前 git 仓库拥有两个远程地址。</p><p>最后，我们修改并测试完成之后可以将修改后的代码推送到我们 fork 的远程地址，这样就可以安全的向源项目提交 PR 了。</p><p>以上为笔者在实践中总结的一种向使用 Go 开发的开源项目贡献代码的解决方案，该方案改动少，对代码没有入侵性，操作简单。如果读者有更好的方式，可以在评论中留言，大家一起探讨。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-Overview&quot;&gt;&lt;a href=&quot;#0-Overview&quot; class=&quot;headerlink&quot; title=&quot;0. Overview&quot;&gt;&lt;/a&gt;0. Overview&lt;/h2&gt;&lt;p&gt;当我们要向一个开源项目贡献代码时通常的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;fork 原项目到自己的账号上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在本地将 fork 的项目下载下来，开发，编译测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地检查没问题之后 push 到自己 fork 的仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按原项目贡献代码规范检查自己的代码以符合规范（一些热门的/专业社区维护的项目一般都有一套贡献规范，如 Kubernetes 、 moby （原 Docker ） 、 Go）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一切安排妥当后向原项目提交 PR 等待合并到原项目分支&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个流程看起来十分简单，但这一套用在 Go 项目仿佛有点行不通了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://blog.atompi.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.atompi.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用 os / exec 在 Go 中执行高级命令</title>
    <link href="https://blog.atompi.com/2019/12/01/%E4%BD%BF%E7%94%A8exec%E5%9C%A8Go%E4%B8%AD%E6%89%A7%E8%A1%8C%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.atompi.com/2019/12/01/%E4%BD%BF%E7%94%A8exec%E5%9C%A8Go%E4%B8%AD%E6%89%A7%E8%A1%8C%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</id>
    <published>2019-12-01T06:08:28.000Z</published>
    <updated>2021-02-23T13:43:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>本文翻译自 <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="noopener">Advanced command execution in Go with os/exec</a> 。</p><p>文中所有代码都可以在原作者开源项目 <a href="https://github.com/kjk/go-cookbook" target="_blank" rel="noopener">go-cookbook</a> 的 <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec" target="_blank" rel="noopener">advanced-exec</a> 目录中获取。</p><p>Go对执行外部程序具有出色的支持。让我们从头开始。</p><p>在我们的示例中，我们将运行 <code>ls -lah</code> 命令，因为它会产生输出。 Windows 上没有 <code>ls</code> ，因此您可以将其更改为其他命令，例如 <code>tasklist</code>。</p><a id="more"></a><h2 id="1-运行命令"><a href="#1-运行命令" class="headerlink" title="1. 运行命令"></a>1. 运行命令</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line">if runtime.GOOS == "windows" {</span><br><span class="line">cmd = exec.Command("tasklist")</span><br><span class="line">}</span><br><span class="line">err := cmd.Run()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/01-simple-exec-v1.go" target="_blank" rel="noopener">advanced-exec/01-simple-exec-v1.go</a></p><p>如果运行它，似乎什么也不会发生。不用担心，该命令实际上已被执行。如果我们在 <code>shell</code> 中运行 <code>ls -lah</code> ， <code>shell</code> 会将 <code>stdout</code> 和 <code>stderr</code> 输出到控制台，以便我们可以看到它。而我们在通过 Go 标准库函数执行程序时，默认情况下 <code>stdout</code> 和 <code>stderr</code> 被丢弃。</p><h2 id="2-运行命令并显示输出"><a href="#2-运行命令并显示输出" class="headerlink" title="2. 运行命令并显示输出"></a>2. 运行命令并显示输出</h2><p>为例看到输出，我们可以将正在执行的程序的输出（ <code>cmd.Stdout</code> 和 <code>cmd.Stderr</code> ）发送到 <code>os.Stdout</code> 和 <code>os.Stderr</code> ，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">err := cmd.Run()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/01-simple-exec-v2.go" target="_blank" rel="noopener">advanced-exec/01-simple-exec-v2.go</a></p><p><code>cmd.Stdout</code> 和 <code>cmd.Stderr</code> 被声明为 <code>io.Writer</code> 接口，因此我们可以将它们设置为实现 <code>Write()</code> 方法的任何类型，例如 <code>os.File</code> 或内存中的缓冲区 <code>bytes.Buffer</code> 。<code>io.Reader</code> 和 <code>io.Writer</code> 是非常简单的但非常强大的且抽象的。</p><h2 id="3-运行命令并捕获输出"><a href="#3-运行命令并捕获输出" class="headerlink" title="3. 运行命令并捕获输出"></a>3. 运行命令并捕获输出</h2><p>上面的示例使我们可以看到输出，但是有时我们想要捕获输出并进行分析，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line">out, err := cmd.CombinedOutput()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br><span class="line">fmt.Printf("combined out:\n%s\n", string(out))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码 <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/01-simple-exec-v3.go" target="_blank" rel="noopener">advanced-exec/01-simple-exec-v3.go</a></p><p><code>CombinedOutput</code> 运行命令并返回包含 <code>stdout</code> 和 <code>stderr</code> 的返回值。</p><h3 id="3-1-CombinedOutput-的实现原理"><a href="#3-1-CombinedOutput-的实现原理" class="headerlink" title="3.1 CombinedOutput 的实现原理"></a>3.1 CombinedOutput 的实现原理</h3><p>Go 的好处在于它是开源的，因此我们可以窥视给定的功能是如何实现的，同时标准库中的大多数代码都很简单。以下是 <code>CombinedOutput</code> 的实现方式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) CombinedOutput() ([]byte, error) {</span><br><span class="line">if c.Stdout != nil {</span><br><span class="line">return nil, errors.New("exec: Stdout already set")</span><br><span class="line">}</span><br><span class="line">if c.Stderr != nil {</span><br><span class="line">return nil, errors.New("exec: Stderr already set")</span><br><span class="line">}</span><br><span class="line">var b bytes.Buffer</span><br><span class="line">c.Stdout = &b</span><br><span class="line">c.Stderr = &b</span><br><span class="line">err := c.Run()</span><br><span class="line">return b.Bytes(), err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出，这几乎和我们的第二个示例一样简单。我们没有将 <code>cmd.Stdout</code> 和 <code>cmd.Stderr</code> 设置为标准输出，而是将它们设置为单个内存缓冲区。程序完成后，我们将所有写入该缓冲区的内容返回。</p><p>因此，<em>不要害怕细读标准库的代码。</em></p><h2 id="4-分别捕获-stdout-和-stderr"><a href="#4-分别捕获-stdout-和-stderr" class="headerlink" title="4. 分别捕获 stdout 和 stderr"></a>4. 分别捕获 stdout 和 stderr</h2><p>如果要执行相同操作但又分别捕获 <code>stdout</code> 和 <code>stderr</code> ，该怎么办？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line">var stdout, stderr bytes.Buffer</span><br><span class="line">cmd.Stdout = &stdout</span><br><span class="line">cmd.Stderr = &stderr</span><br><span class="line">err := cmd.Run()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br><span class="line">outStr, errStr := string(stdout.Bytes()), string(stderr.Bytes())</span><br><span class="line">fmt.Printf("out:\n%s\nerr:\n%s\n", outStr, errStr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/02-capture-stdout-stderr.go" target="_blank" rel="noopener">advanced-exec/02-capture-stdout-stderr.go</a></p><h2 id="5-捕获输出同时显示执行过程中的输出"><a href="#5-捕获输出同时显示执行过程中的输出" class="headerlink" title="5. 捕获输出同时显示执行过程中的输出"></a>5. 捕获输出同时显示执行过程中的输出</h2><p>对于有以下需求的程序：</p><ul><li>命令需要很长时间才能完成</li><li>除了捕获 <code>stdout</code> / <code>stderr</code> 之外，还需要在控制台上看到它的执行过程。</li></ul><p>此时我们需要在捕获输出的同时捕获执行过程。这里涉及到的东西有点多，但并不难理解。</p><h3 id="5-1-捕获输出同时显示执行过程中的输出-1"><a href="#5-1-捕获输出同时显示执行过程中的输出-1" class="headerlink" title="5.1 捕获输出同时显示执行过程中的输出 #1"></a>5.1 捕获输出同时显示执行过程中的输出 #1</h3><p>首先，一个帮助程序功能可以从读取器复制到写入器，还可以捕获复制的数据：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func copyAndCapture(w io.Writer, r io.Reader) ([]byte, error) {</span><br><span class="line">var out []byte</span><br><span class="line">buf := make([]byte, 1024, 1024)</span><br><span class="line">for {</span><br><span class="line">n, err := r.Read(buf[:])</span><br><span class="line">if n > 0 {</span><br><span class="line">d := buf[:n]</span><br><span class="line">out = append(out, d...)</span><br><span class="line">_, err := w.Write(d)</span><br><span class="line">if err != nil {</span><br><span class="line">return out, err</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">if err != nil {</span><br><span class="line">// Read returns io.EOF at the end of file, which is not an error for us</span><br><span class="line">if err == io.EOF {</span><br><span class="line">err = nil</span><br><span class="line">}</span><br><span class="line">return out, err</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>处理 <code>Read</code> 中的错误非常微妙。 <code>io.EOF</code> 错误意味着我们已经读取了所有内容。这实际上不是错误，因此我们将 <code>io.EOF</code> 设置为 <code>nil</code> 。</p><p>最终代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line"></span><br><span class="line">var stdout, stderr []byte</span><br><span class="line">var errStdout, errStderr error</span><br><span class="line">stdoutIn, _ := cmd.StdoutPipe()</span><br><span class="line">stderrIn, _ := cmd.StderrPipe()</span><br><span class="line">err := cmd.Start()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Start() failed with '%s'\n", err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// cmd.Wait() should be called only after we finish reading</span><br><span class="line">// from stdoutIn and stderrIn.</span><br><span class="line">// wg ensures that we finish</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func() {</span><br><span class="line">stdout, errStdout = copyAndCapture(os.Stdout, stdoutIn)</span><br><span class="line">wg.Done()</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">stderr, errStderr = copyAndCapture(os.Stderr, stderrIn)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">err = cmd.Wait()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br><span class="line">if errStdout != nil || errStderr != nil {</span><br><span class="line">log.Fatal("failed to capture stdout or stderr\n")</span><br><span class="line">}</span><br><span class="line">outStr, errStr := string(stdout), string(stderr)</span><br><span class="line">fmt.Printf("\nout:\n%s\nerr:\n%s\n", outStr, errStr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/03-live-progress-and-capture-v1.go" target="_blank" rel="noopener">advanced-exec/03-live-progress-and-capture-v1.go</a></p><p>我们有两个输出要复制。为避免序列化它们，我们将在 <code>goroutine</code> 中读取其中一个。</p><p>正如 <code>StdoutPipe</code> 的文档警告，在程序完成时 <code>Wait</code> 将关闭管道。如果我们还没有读完，可能会导致输出丢失。为防止这种情况，我们使用 <code>sync.WaitGroup</code> 来确保在调用 <code>cmd.Wait</code> 之前 <code>gorutine</code> 处理 <code>os.Stdout</code> 的操作完成了读取。</p><p>我鼓励你阅读 <code>cmd.StdoutPipe</code> 的实现。尽管代码很短，但是会让你感到惊讶。</p><h3 id="5-2-捕获输出同时显示执行过程中的输出-＃2"><a href="#5-2-捕获输出同时显示执行过程中的输出-＃2" class="headerlink" title="5.2 捕获输出同时显示执行过程中的输出 ＃2"></a>5.2 捕获输出同时显示执行过程中的输出 ＃2</h3><p>以前的解决方案有效，但 <code>copyAndCapture</code> 看起来像我们在重新实现 <code>io.Copy</code> 。由于 Go 使用了接口，因此我们可以重复使用 <code>io.Copy</code> 。</p><p>我们将编写实现 <code>io.Writer</code> 接口的 <code>CapturingPassThroughWriter</code> 结构。它将捕获写入其中的所有内容，并将其写入底层的 <code>io.Writer</code> 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// CapturingPassThroughWriter is a writer that remembers</span><br><span class="line">// data written to it and passes it to w</span><br><span class="line">type CapturingPassThroughWriter struct {</span><br><span class="line">buf bytes.Buffer</span><br><span class="line">w io.Writer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// NewCapturingPassThroughWriter creates new CapturingPassThroughWriter</span><br><span class="line">func NewCapturingPassThroughWriter(w io.Writer) *CapturingPassThroughWriter {</span><br><span class="line">return &CapturingPassThroughWriter{</span><br><span class="line">w: w,</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (w *CapturingPassThroughWriter) Write(d []byte) (int, error) {</span><br><span class="line">w.buf.Write(d)</span><br><span class="line">return w.w.Write(d)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Bytes returns bytes written to the writer</span><br><span class="line">func (w *CapturingPassThroughWriter) Bytes() []byte {</span><br><span class="line">return w.buf.Bytes()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line"></span><br><span class="line">var errStdout, errStderr error</span><br><span class="line">stdoutIn, _ := cmd.StdoutPipe()</span><br><span class="line">stderrIn, _ := cmd.StderrPipe()</span><br><span class="line">stdout := NewCapturingPassThroughWriter(os.Stdout)</span><br><span class="line">stderr := NewCapturingPassThroughWriter(os.Stderr)</span><br><span class="line">err := cmd.Start()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Start() failed with '%s'\n", err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(1)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line">_, errStdout = io.Copy(stdout, stdoutIn)</span><br><span class="line">wg.Done()</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">_, errStderr = io.Copy(stderr, stderrIn)</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">err = cmd.Wait()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br><span class="line">if errStdout != nil || errStderr != nil {</span><br><span class="line">log.Fatalf("failed to capture stdout or stderr\n")</span><br><span class="line">}</span><br><span class="line">outStr, errStr := string(stdout.Bytes()), string(stderr.Bytes())</span><br><span class="line">fmt.Printf("\nout:\n%s\nerr:\n%s\n", outStr, errStr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/03-live-progress-and-capture-v2.go" target="_blank" rel="noopener">advanced-exec/03-live-progress-and-capture-v2.go</a></p><h3 id="5-3-捕获输出同时显示执行过程中的输出-＃3"><a href="#5-3-捕获输出同时显示执行过程中的输出-＃3" class="headerlink" title="5.3 捕获输出同时显示执行过程中的输出 ＃3"></a>5.3 捕获输出同时显示执行过程中的输出 ＃3</h3><p>事实上， Go 的标准库实现了 <a href="https://golang.org/pkg/io/#MultiWriter" target="_blank" rel="noopener"><code>io.MultiWriter</code></a> ，它是 <code>CapturingPassThroughWriter</code> 的通用版本。让我们用它代替：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">cmd := exec.Command("ls", "-lah")</span><br><span class="line"></span><br><span class="line">var stdoutBuf, stderrBuf bytes.Buffer</span><br><span class="line">stdoutIn, _ := cmd.StdoutPipe()</span><br><span class="line">stderrIn, _ := cmd.StderrPipe()</span><br><span class="line"></span><br><span class="line">var errStdout, errStderr error</span><br><span class="line">stdout := io.MultiWriter(os.Stdout, &stdoutBuf)</span><br><span class="line">stderr := io.MultiWriter(os.Stderr, &stderrBuf)</span><br><span class="line">err := cmd.Start()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Start() failed with '%s'\n", err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(1)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line">_, errStdout = io.Copy(stdout, stdoutIn)</span><br><span class="line">wg.Done()</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">_, errStderr = io.Copy(stderr, stderrIn)</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">err = cmd.Wait()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br><span class="line">if errStdout != nil || errStderr != nil {</span><br><span class="line">log.Fatal("failed to capture stdout or stderr\n")</span><br><span class="line">}</span><br><span class="line">outStr, errStr := string(stdoutBuf.Bytes()), string(stderrBuf.Bytes())</span><br><span class="line">fmt.Printf("\nout:\n%s\nerr:\n%s\n", outStr, errStr)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/03-live-progress-and-capture-v3.go" target="_blank" rel="noopener">advanced-exec/03-live-progress-and-capture-v3.go</a></p><p>能够自己编写代码是件好事，但更好地了解标准库则更好！</p><h2 id="6-写入程序的标准输入（-stdin-）"><a href="#6-写入程序的标准输入（-stdin-）" class="headerlink" title="6. 写入程序的标准输入（ stdin ）"></a>6. 写入程序的标准输入（ stdin ）</h2><p>我们知道如何读取程序的 <code>stdout</code> ，但我们也可以写入其 <code>stdin</code> 。</p><p>目前没有 Go 标准库可以执行 <code>bzip2</code> 压缩（标准库中仅提供解压缩功能）。我们可以通过以下方式使用 <code>bzip2</code> 进行压缩：（将数据写入临时文件）调用 <code>bzip2 -c $ {file_in}</code> 并捕获其 <code>stdout</code>。</p><p>如果我们不创建临时文件就更好了。大多数压缩程序接受数据以在 <code>stdin</code> 上进行压缩 / 解压缩。要在命令行上执行此操作，我们将使用以下命令： <code>bzip2 -c <$ {file_in}> $ {file_out}</code> 。</p><p>下面就是使用 Go 实现这一操作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// compress data using bzip2 without creating temporary files</span><br><span class="line">func bzipCompress(d []byte) ([]byte, error) {</span><br><span class="line">var out bytes.Buffer</span><br><span class="line">// -c : compress</span><br><span class="line">// -9 : select the highest level of compresion</span><br><span class="line">cmd := exec.Command("bzip2", "-c", "-9")</span><br><span class="line">cmd.Stdin = bytes.NewBuffer(d)</span><br><span class="line">cmd.Stdout = &out</span><br><span class="line">err := cmd.Run()</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line">return out.Bytes(), nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/06-feed-stdin.go" target="_blank" rel="noopener">advanced-exec/06-feed-stdin.go</a></p><p>我们还可以调用 <code>cmd.StdinPipe()</code> ，它返回 <code>io.WriteCloser</code> 。它比较复杂，但是可以更好地控制我们的代码量。</p><h2 id="7-改变执行程序的环境"><a href="#7-改变执行程序的环境" class="headerlink" title="7. 改变执行程序的环境"></a>7. 改变执行程序的环境</h2><p>有关 Go 中环境变量的注意事项：</p><ul><li><code>os.Environ()</code> 返回一个 <code>[]string</code> ，其中每个字符串的形式为 <code>FOO=bar</code> ，其中 <code>FOO</code> 是环境变量的名称， <code>bar</code> 是值</li><li><code>os.Getenv("FOO")</code> 返回环境变量 <code>FOO</code> 的值</li></ul><p>有时您需要修改执行程序的环境。 Go 通过设置 <code>exec.Cmd</code> 的 <code>Env</code> 成员来支持这一点。 <code>cmd.Env</code> 与 <code>os.Environ()</code> 的格式相同。如果未设置 <code>Env</code> ，则进程将继承调用进程的环境。</p><p>如果你不想从头开始构建一个全新的环境，而是传递当前流程环境的修改版本。可以使用以下添加新变量的方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmd := exec.Command("programToExecute")</span><br><span class="line"></span><br><span class="line">additionalEnv := "FOO=bar"</span><br><span class="line">newEnv := append(os.Environ(), additionalEnv))</span><br><span class="line">cmd.Env = newEnv</span><br><span class="line"></span><br><span class="line">out, err := cmd.CombinedOutput()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("cmd.Run() failed with %s\n", err)</span><br><span class="line">}</span><br><span class="line">fmt.Printf("%s", out)</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/05-change-environment.go" target="_blank" rel="noopener">advanced-exec/05-change-environment.go</a></p><p>如果要删除环境或确保不设置两次相同的变量，那么就不这么简单了。幸好软件包 <a href="https://godoc.org/github.com/shurcooL/go/osutil#Environ" target="_blank" rel="noopener"><code>shurcooL/go/osutil</code></a> 提供了一种操作环境变量的简便方法。</p><h2 id="8-提前检查要执行的程序是否可被执行"><a href="#8-提前检查要执行的程序是否可被执行" class="headerlink" title="8. 提前检查要执行的程序是否可被执行"></a>8. 提前检查要执行的程序是否可被执行</h2><p>想象一下，你编写了一个需要很长时间才能运行的程序。最后，你调用可执行文件 <code>foo</code> 执行基本任务，此时如果不存在 <code>foo</code> 可执行文件，则调用将失败，前功尽弃。</p><p>因此，最好在开始的时侯就检测到缺少可执行文件 <code>foo</code> ，并在出现描述性错误消息时尽早结束执行。可以使用 <code>exec.LookPath</code> 做到这一点：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func checkLsExists() {</span><br><span class="line">path, err := exec.LookPath("ls")</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Printf("didn't find 'ls' executable\n")</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("'ls' executable is in '%s'\n", path)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/04-check-exe-exists.go" target="_blank" rel="noopener">advanced-exec/04-check-exe-exists.go</a></p><p>检查程序是否存在的另一种方法是尝试在无操作模式下执行它（例如，许多程序都支持 <code>--help</code> 选项）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-Overview&quot;&gt;&lt;a href=&quot;#0-Overview&quot; class=&quot;headerlink&quot; title=&quot;0. Overview&quot;&gt;&lt;/a&gt;0. Overview&lt;/h2&gt;&lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Advanced command execution in Go with os/exec&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;文中所有代码都可以在原作者开源项目 &lt;a href=&quot;https://github.com/kjk/go-cookbook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;go-cookbook&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/kjk/go-cookbook/blob/master/advanced-exec&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;advanced-exec&lt;/a&gt; 目录中获取。&lt;/p&gt;
&lt;p&gt;Go对执行外部程序具有出色的支持。让我们从头开始。&lt;/p&gt;
&lt;p&gt;在我们的示例中，我们将运行 &lt;code&gt;ls -lah&lt;/code&gt; 命令，因为它会产生输出。 Windows 上没有 &lt;code&gt;ls&lt;/code&gt; ，因此您可以将其更改为其他命令，例如 &lt;code&gt;tasklist&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://blog.atompi.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.atompi.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>如何快速构建一个 Go 语言开发环境</title>
    <link href="https://blog.atompi.com/2019/11/30/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.atompi.com/2019/11/30/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2019-11-30T06:18:31.000Z</published>
    <updated>2021-02-23T13:43:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>本文适用于 Linux 环境；</p></li><li><p>本文主体只对 Go 编译环境做一些简单的配置，如：环境变量、目录规划。</p></li><li><p>本文末尾会附带一些有用的工具，对 Go 学习和开发都有很大帮助。</p></li></ul><a id="more"></a><h2 id="开始构建-Go-编译环境"><a href="#开始构建-Go-编译环境" class="headerlink" title="开始构建 Go 编译环境"></a>开始构建 Go 编译环境</h2><ul><li>安装 C/C++ 构建工具链（使用 CGO 特性）</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"># CentOS</span><br><span class="line">sudo yum groupinstall "Development Tools"</span><br></pre></td></tr></tbody></table></figure><ul><li>下载 Go 二进制包</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Downloads</span><br><span class="line">GO_VERSION=1.13.4 && wget https://dl.google.com/go/go$GO_VERSION.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure><ul><li>解压 Go 二进制包并移动到 <code>/usr/local/go</code> 目录</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Downloads</span><br><span class="line">GO_VERSION=1.13.4 && tar -zxf go$GO_VERSION.linux-amd64.tar.gz</span><br><span class="line">sudo mv go /usr/local/</span><br></pre></td></tr></tbody></table></figure><ul><li>创建一些必要和不必要但建议创建并指定的目录</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/goworkdir/{go,go-build}</span><br><span class="line">sudo chown -R $USER:$USER /data/goworkdir</span><br></pre></td></tr></tbody></table></figure><ul><li>修改环境变量</li></ul><p>只对当前用户生效：</p><p>对于 <code>bash</code> 用户，在 <code>$HOME/bashrc</code> 末尾新增以下内容；对于 <code>zsh</code> 用户，在 <code>$HOME/.zshrc</code> 末尾新增以下内容</p><p>对所有用户生效：</p><p>对于 Ubuntu 发行版， <code>bash</code> 用户在 <code>/etc/bash.bashrc</code> 末尾新增以下内容；<code>zsh</code> 用户，在 <code>/etc/zsh/zshrc</code> 末尾新增以下内容</p><p>对于 CentOS 发行版， <code>bash</code> 用户在 <code>/etc/profile</code> 末尾新增以下内容；<code>zsh</code> 用户，在 <code>/etc/zsh/zshrc</code> 末尾新增以下内容</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/data/goworkdir/go</span><br><span class="line">export GOCACHE=/data/goworkdir/go-build</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></tbody></table></figure><p>环境变量修改完成后退出当前用户重新登陆后生效，验证： <code>go env</code> 可输出 Go 环境信息</p><h2 id="一些有用的工具"><a href="#一些有用的工具" class="headerlink" title="一些有用的工具"></a>一些有用的工具</h2><ol><li>zeal —— 离线 API 文档神器</li></ol><p>下载地址：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zealdocs.org/</span><br></pre></td></tr></tbody></table></figure><p>zeal 自带的 API 文档依赖于 <a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a> 项目，包含了众多的 API 文档和权威指南（包含 Go ），如果不够可以从下面的地址中获取更多社区维护的第三方 API 文档和 cheatsheets</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cheatsheets</span><br><span class="line">https://zeal-cheatsheets.herokuapp.com/</span><br><span class="line"># Docsets</span><br><span class="line">https://zealusercontributions.herokuapp.com/</span><br></pre></td></tr></tbody></table></figure><p>如果还觉得不够（确实不够，没有 GoDoc ），这时候需要我们自己构建 Docset 导入了，这里只介绍 GoDoc 的构建，其他 Docset 的构建方式可以在<a href="https://kapeli.com/docsets" target="_blank" rel="noopener">这里</a>找到。</p><p>构建 GoDoc 使用 <a href="https://github.com/wuudjac/godocdash" target="_blank" rel="noopener">godocdash</a> 项目完成，原理大概是使用 <code>godoc</code> 工具在本地生成 GoDoc 然后通过暴露的 url 爬取内容并生成支持 Dash 格式的 docset 。</p><ul><li>构建流程：</li></ul><p>下载 Go 二进制包中不包含 godoc 工具，需要我们自行安装。</p><p>创建一个目录用来存放所有的 go 项目，如笔者使用 GoLand 开发，所有的 go 项目全部存放在 <code>/home/atompi/workdir/GolandProjects/</code> 目录下，下面我们把它简称为 <code>projectsDir</code></p><p>在 <code>projectsDir</code> 下创建一个 <code>godoc</code> 文件夹（注意与项目名同名，但这不是源码文件）用来存放与该项目相关的所有文件（建议今后不管是个人创建的还是引用社区的项目都按这种格式统一管理）。</p><p>进入 <code>projectsDir/godoc</code> 目录下载 <code>godoc</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></tbody></table></figure><p>为 <code>godocd</code> 可执行文件创建软链接，以便在命令行直接使用 <code>godoc</code> 命令。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># go get 命令会在 projectsDir/godoc 目录下创建 bin 目录存放编译好的可执行文件</span><br><span class="line">sudo ln -s /home/atompi/workdir/GolandProjects/godoc/bin/godoc /usr/local/bin/</span><br></pre></td></tr></tbody></table></figure><p>在 <code>projectsDir</code> 下创建一个 <code>godocdash</code> 文件夹</p><p>进入 <code>projectsDir/godocdash</code> 目录下载 <code>godocdash</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br><span class="line">go get github.com/wuudjac/godocdash</span><br></pre></td></tr></tbody></table></figure><p>为 <code>godocdash</code> 可执行文件创建软链接，以便在命令行直接使用 <code>godocdash</code> 命令。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/atompi/workdir/GolandProjects/godocdash/bin/godocdash /usr/local/bin/</span><br></pre></td></tr></tbody></table></figure><p>创建 <code>projectsDir/godocmaker</code> 目录，用来存放待构建 GoDoc 的项目源码和构建出来的 Docset</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/atompi/workdir/GolandProjects/godocmaker</span><br></pre></td></tr></tbody></table></figure><p>下载待构建 GoDoc 的项目源码，以 <code>github.com/prometheus/client_golang</code> 为例</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/atompi/workdir/GolandProjects/godocmaker</span><br><span class="line">export GOPATH=`pwd`</span><br><span class="line"># 只下载，不编译</span><br><span class="line">go get -d github.com/prometheus/client_golang</span><br></pre></td></tr></tbody></table></figure><p>构建 Docset ，在 <code>projectsDir/godocmaker</code> 目录下执行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godocdash</span><br></pre></td></tr></tbody></table></figure><p>把构建出来的 Docset 移动到 zeal Docset 目录（ ~/.local/share/Zeal/Zeal/docsets/ ），重启 zeal 后就可以离线查看 GoDoc 了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv GoDoc.docset ~/.local/share/Zeal/Zeal/docsets/</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>tour —— Go 学习神器</li></ol><p><a href="https://tour.go-zh.org/" target="_blank" rel="noopener">tour 中文版</a> 是 Go 编程语言指南（ <a href="https://tour.golang.org/" target="_blank" rel="noopener">A Tour of Go</a> ）的中文社区维护版本，是学习 Go 语言（入门）最好的途径。 tour 工具可以开启一个 web 页面，以实例的方式介绍 Go 编程语言，用户可以在页面上直接编写简单的 Go 代码并实时执行获取执行结果。 tour 通过共有云的方式提供一个公共的入口，只要你能连接互联网就可以随时随地访问和使用，同时 tour 还提供了离线版本，以便在你无法连接互联网是同样可以通过 tour 工具学习和实践。</p><p>安装离线版 tour 非常简单只需要执行以下命令即可。</p><p>创建 <code>projectsDir/tour</code> 目录并在目录中执行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br><span class="line"># 安装中文版</span><br><span class="line">go get github.com/Go-zh/tour</span><br><span class="line"># 安装英文原版</span><br><span class="line">go get golang.org/x/tour</span><br></pre></td></tr></tbody></table></figure><p>建议为 <code>tour</code> 可执行文件创建软链接，以便在命令行直接使用 <code>tour</code> 命令。</p><p>命令行执行 <code>tour</code> 会自动打开默认浏览器并进入本地的 tour 主页</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本文适用于 Linux 环境；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本文主体只对 Go 编译环境做一些简单的配置，如：环境变量、目录规划。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本文末尾会附带一些有用的工具，对 Go 学习和开发都有很大帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://blog.atompi.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.atompi.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Kubernetes 源码编译环境</title>
    <link href="https://blog.atompi.com/2019/10/26/%E6%90%AD%E5%BB%BAkubernetes%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.atompi.com/2019/10/26/%E6%90%AD%E5%BB%BAkubernetes%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</id>
    <published>2019-10-26T06:08:51.000Z</published>
    <updated>2021-02-23T13:43:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>虽然可以使用本地 golang 安装来构建 Kubernetes，但在 Docker 容器中运行的构建过程简化了初始设置，并提供了非常一致的构建和测试环境。尽管如此，本文还是会介绍本地 golang 和 Docker 容器两种构建方式，以供读者自由选择。</p><a id="more"></a><h2 id="1-本地-golang-构建（适用于对-Kubernetes-有二次开发-源码阅读需求的用户）"><a href="#1-本地-golang-构建（适用于对-Kubernetes-有二次开发-源码阅读需求的用户）" class="headerlink" title="1. 本地 golang 构建（适用于对 Kubernetes 有二次开发/源码阅读需求的用户）"></a>1. 本地 golang 构建（适用于对 Kubernetes 有二次开发/源码阅读需求的用户）</h2><h3 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h3><ul><li>安装 Golang</li></ul><p>见<a href="https://atompi.io/2019/11/30/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">如何快速构建一个 Go 语言开发环境</a></p><h3 id="1-2-下载-Kubernetes-源码"><a href="#1-2-下载-Kubernetes-源码" class="headerlink" title="1.2 下载 Kubernetes 源码"></a>1.2 下载 Kubernetes 源码</h3><p><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">项目地址</a></p><p>项目默认分支为 <code>master</code> 可以使用以下命令下载指定分支 / tag ：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建并进入 Kubernetes 专用的 workdir ，如：</span><br><span class="line">mkdir -p /home/atompi/workdir/GolandProjects/Kubernetes</span><br><span class="line">cd /home/atompi/workdir/GolandProjects/Kubernetes</span><br><span class="line">export GOPATH=`pwd`</span><br><span class="line">mkdir -p $GOPATH/src/k8s.io</span><br><span class="line">cd $GOPATH/src/k8s.io</span><br><span class="line">git clone https://github.com/kubernetes/kubernetes -b <branch/tag name></span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h3><p><code>KUBE_BUILD_PLATFORMS</code> 指定目标平台， <code>WHAT</code> 指定编译的组件，通过 <code>GOFLAGS</code> 和 <code>GOGCFLAGS</code> 传入编译时参数，如此处编译 <code>kubelet</code> 组件。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBE_BUILD_PLATFORMS=linux/amd64 make all WHAT=cmd/kubelet GOFLAGS=-v GOGCFLAGS="-N -l"</span><br></pre></td></tr></tbody></table></figure><p>make 参数说明：</p><ul><li><code>WHAT</code> ：指定需要编译的包如 <code>WHAT=cmd/kubelet</code> ，如果不指定则编译全部</li><li><code>all</code> ：在本地环境中进行编译，相对于 <code>release</code> 、 <code>quick-release</code> 是在容器中完成编译并打包成 Docker 镜像，默认为 <code>all</code></li><li><code>clean</code> :清理编译结果以便重新编译</li></ul><h3 id="快速编译"><a href="#快速编译" class="headerlink" title="快速编译"></a>快速编译</h3><p>编译过程较长，编译后的文件在 <code>_output</code> 里。可以在 <code>cmd/xxx</code> 目录下执行 <code>go build -v</code> 构建当前平台下当前的二进制包，构建结果直接输出在当前文件夹。如快速构建 kubelet ：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd cmd/kubelet</span><br><span class="line">go build -v</span><br></pre></td></tr></tbody></table></figure><h2 id="2-在-Docker-容器中运行构建"><a href="#2-在-Docker-容器中运行构建" class="headerlink" title="2. 在 Docker 容器中运行构建"></a>2. 在 Docker 容器中运行构建</h2><h3 id="2-1-环境要求"><a href="#2-1-环境要求" class="headerlink" title="2.1 环境要求"></a>2.1 环境要求</h3><p>只需要在本地安装 Docker daemon 即可</p><h3 id="2-2-关键性脚本（构建命令及说明）"><a href="#2-2-关键性脚本（构建命令及说明）" class="headerlink" title="2.2 关键性脚本（构建命令及说明）"></a>2.2 关键性脚本（构建命令及说明）</h3><p>以下脚本都可以在 <code>build/</code> 目录中找到。注意：所有脚本必须在 Kubernetes 根目录（即 <code>$GOPATH/src/k8s.io/kubernetes</code> ）运行。</p><ul><li><p><code>build/run.sh</code> ：在用来构建的 docker 容器中运行命令。常用的有以下调用参数：</p><ul><li><code>build/run.sh make</code>：运行构建，默认仅构建 linux 所有二进制文件。可以根据需要传递 make 参数来跨平台构建或者构建指定包，如下：</li><li><code>build/run.sh make cross</code> ：构建所有平台的所有二进制文件</li><li><code>build/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64</code> ：为特定平台构建特定二进制文件（如这行命令表示只构建 <code>darwin/amd64</code> 平台的 <code>kubelet</code> 二进制文件）</li><li><code>build/run.sh make test</code> ：运行所有单元测试</li><li><code>build/run.sh make test-integration</code> ：运行集成测试</li><li><code>build/run.sh make test-cmd</code> ：运行 CLI 测试</li></ul></li><li><p><code>build/copy-output.sh</code> ：将构建结果从 Docker 容器的 <code>_output/dockerized/bin</code> 文件夹复制到本地 <code>_output/dockerized/bin</code> 文件夹同时复制在构建过程中生成的特定文件属性。该命令已经在 <code>build/run.sh</code> 中自动运行，也可在完成构建后单独多次运行。</p></li><li><p><code>build/make-clean.sh</code> ：清除本地 <code>_output</code> 的内容，删除所有本地构建的容器镜像，删除 Docker 持久化数据卷，即清空构建过程中产生的所有文件。</p></li><li><p><code>build/shell.sh</code> ：进入挂载有当前代码的构建容器中，相当于 <code>docker exec -it <Container> bash</code></p></li></ul><h3 id="2-3-基本流程"><a href="#2-3-基本流程" class="headerlink" title="2.3 基本流程"></a>2.3 基本流程</h3><ol><li><p>位于 <code>build/</code> 目录下（父目录下，不包含子目录下）的脚本用于构建和测试。这些脚本用于构建 <code>kube-build</code> Docker 镜像（基于 <code>build/build-image/Dockerfile</code> 构建），然后在基于该镜像启动的容器中执行构建命令。这些脚本同时确保每次运行都缓存正确的数据以进行增量构建，并将结果复制回容器。</p></li><li><p>通过首先在 <code>_output/images/build-image</code> 中创建一个 <code>context</code> 目录来构建 <code>kube-build</code> 容器镜像。在 <code>context</code> 而不是在 <code>Kubernetes</code> 存储库的根目录进行镜像构建，可以以最大程度地减少构建镜像时需要打包的数据量。</p></li><li><p>从此镜像运行 3 个不同的容器实例。第一个是持久化数据卷（ <code>data</code> ）容器，用于存储需要持久存储以支持增量构建的所有数据。接下来是一个同步（ <code>rsync</code> ）容器，用于将数据传入和传出到持久化数据卷容器。最后一个是构建（ <code>build</code> ）容器，用于实际执行构建操作。每次运行后，持久化数据卷容器在运行期间都将保留，而同步和构建容器将被删除。</p></li><li><p><code>rsync</code> 在后台透明地使用，以有效地将数据移入和移出容器。这将使用 Docker 选择的临时端口。您可以通过设置 <code>KUBE_RSYNC_PORT</code> 变量来修改它。</p></li><li><p>所有 Docker 名称都以从文件路径派生的哈希作为后缀（以允许在 CI 机器上同时使用）和版本号。当版本号更改时，所有状态都将清除，并开始全新构建。这允许更改构建基础结构，并向 CI 系统发出需要删除旧工件的信号。</p></li></ol><h3 id="2-4-代理设置"><a href="#2-4-代理设置" class="headerlink" title="2.4 代理设置"></a>2.4 代理设置</h3><p>如果你需要通过代理上网，并且让这些脚本使用 docker-machine 在 macOS 上为你设置本地 VM ，则需要配置 Kubernetes 构建的代理设置，具体操作为定义以下环境变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export KUBERNETES_HTTP_PROXY=http://username:password@proxyaddr:proxyport</span><br><span class="line">export KUBERNETES_HTTPS_PROXY=https://username:password@proxyaddr:proxyport</span><br></pre></td></tr></tbody></table></figure><p>同时可以选择为 Kubernetes 构建指定不需要代理的地址，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBERNETES_NO_PROXY=127.0.0.1</span><br></pre></td></tr></tbody></table></figure><p>如果使用 sudo 进行 Kubernetes 的构建（例如 <code>make quick-release</code> ），则需要运行 <code>sudo -E make quick-release</code> 来传递环境变量。</p><h3 id="2-5-使用远程-Docker-engine-构建（不推荐）"><a href="#2-5-使用远程-Docker-engine-构建（不推荐）" class="headerlink" title="2.5 使用远程 Docker engine 构建（不推荐）"></a>2.5 使用远程 Docker engine 构建（不推荐）</h3><p>原理同使用本地 Docker engine 构建，只是需要通过配置环境变量将远程的 Docker engine 当作本地使用（需要创建 SSH Tunnel 将本地 rsync 端口映射到远程以从远程将构建结果复制回本地）</p><p>详细操作这里不作介绍，可参考<a href="https://github.com/kubernetes/kubernetes/tree/master/build#really-remote-docker-engine" target="_blank" rel="noopener">官方配置</a></p><h3 id="2-6-构建发行版"><a href="#2-6-构建发行版" class="headerlink" title="2.6 构建发行版"></a>2.6 构建发行版</h3><p><code>build/release.sh</code> 脚本将构建发行版。它将构建二进制文件、运行测试同时构建 Docker 映像（可选）。</p><p>构建结果是 tar 文件：主要是 <code>kubernetes.tar.gz</code> ，这个 tar 文件中包括：</p><ul><li>交叉编译的客户端。</li><li>kubectl ，用于基于平台选择和运行正确的客户端二进制文件。</li><li>Examples</li><li>各种云的集群部署脚本</li><li>包含所有服务端二进制文件的 tar 文件</li></ul><p>此外，还创建了其他一些 tar 文件：</p><ul><li><code>kubernetes-client-*.tar.gz</code> 特定平台的客户端二进制文件</li><li><code>kubernetes-server-*.tar.gz</code> 特定平台的服务端二进制文件</li></ul><p>构建最终发行版 tar 时，tar 包里面的文件会暂存在 <code>_output/release-stage</code> ，然后再将其打入 tar 包到 <code>_output/release-tars</code> 目录下。</p><h3 id="2-7-可重复性的构建环境（-Reproducible-Builds-项目）"><a href="#2-7-可重复性的构建环境（-Reproducible-Builds-项目）" class="headerlink" title="2.7 可重复性的构建环境（ Reproducible Builds 项目）"></a>2.7 可重复性的构建环境（ Reproducible Builds 项目）</h3><p>可重复性的构建是一组软件开发实践，可创建从源代码到二进制代码的独立可验证路径。见 <a href="https://reproducible-builds.org/docs/definition/" target="_blank" rel="noopener">Reproducible builds</a></p><p><code>make release</code> 、其派生的 <code>make quick-release</code> 以及 <a href="https://www.bazel.build/" target="_blank" rel="noopener">Bazel 构建工具</a> 都提供了一个封闭的构建环境，为构建提供一定程度的可重复性（ <code>make</code> 本身是不封闭的）。</p><p>Kubernetes 构建环境支持 Reproducible Builds 项目指定的 <a href="https://reproducible-builds.org/specs/source-date-epoch/" target="_blank" rel="noopener"><code>SOURCE_DATE_EPOCH</code> 环境变量</a>，可以将其设置为 UNIX 时间戳。这将用于嵌入已编译的 Go 二进制文件中的构建时间戳，也许未来还会用于 Docker 映像。这个变量的一个合理设置是使用从正在构建的树的顶端开始的提交时间戳（这是Kubernetes CI 系统使用的）。例如，可以使用以下设置：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOURCE_DATE_EPOCH=$(git show -s --format=format:%ct HEAD)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-Overview&quot;&gt;&lt;a href=&quot;#0-Overview&quot; class=&quot;headerlink&quot; title=&quot;0. Overview&quot;&gt;&lt;/a&gt;0. Overview&lt;/h2&gt;&lt;p&gt;虽然可以使用本地 golang 安装来构建 Kubernetes，但在 Docker 容器中运行的构建过程简化了初始设置，并提供了非常一致的构建和测试环境。尽管如此，本文还是会介绍本地 golang 和 Docker 容器两种构建方式，以供读者自由选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://blog.atompi.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://blog.atompi.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>搭建 docker 源码编译环境</title>
    <link href="https://blog.atompi.com/2019/01/29/%E6%90%AD%E5%BB%BAdocker%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.atompi.com/2019/01/29/%E6%90%AD%E5%BB%BAdocker%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</id>
    <published>2019-01-29T06:08:51.000Z</published>
    <updated>2021-02-23T13:43:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-下载-moby-moby-源码"><a href="#0-下载-moby-moby-源码" class="headerlink" title="0. 下载 moby/moby 源码"></a>0. 下载 moby/moby 源码</h2><p>如果想要为 docker 贡献代码，则要进行以下步骤：</p><ol><li><p>Fork and clone the Moby code ： Fork 后 clone moby 源码</p></li><li><p>Set your signature and an upstream remote ：设置签名和上游 remote</p></li></ol><p>当你向 Docker 贡献代码时，你必须证明你同意（ <a href="http://developercertificate.org/" target="_blank" rel="noopener">Developer Certificate of Origin</a> ）开发人员原产地证书。你通过签署你的 git 提交来表明您的同意，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signed-off-by: Pat Smith <pat.smith@email.com></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>具体做法：</li></ol><a id="more"></a><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name "FirstName LastName"    # 必须是真实姓名</span><br><span class="line">git config --local user.email "emailname@mycompany.com"    # 必须是有效可用的邮箱</span><br><span class="line">git remote add upstream https://github.com/moby/moby.git</span><br><span class="line"># 提交代码时使用 git commit -s 自动签署</span><br><span class="line">git commit -s -m "Making a dry run test."</span><br></pre></td></tr></tbody></table></figure><h2 id="1-净化本地-Docker-环境-Remove-images-and-containers"><a href="#1-净化本地-Docker-环境-Remove-images-and-containers" class="headerlink" title="1. 净化本地 Docker 环境 Remove images and containers"></a>1. 净化本地 Docker 环境 Remove images and containers</h2><p><em>这个步骤并非必要的，但是是推荐的： Moby developers run the latest stable release of the Docker software. They clean their local hosts of unnecessary Docker artifacts such as stopped containers or unused images. Cleaning unnecessary artifacts isn’t strictly necessary, but it is good practice, so it is included here.</em></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></tbody></table></figure><h2 id="2-启动开发环境容器-Start-a-development-container"><a href="#2-启动开发环境容器-Start-a-development-container" class="headerlink" title="2. 启动开发环境容器 Start a development container"></a>2. 启动开发环境容器 Start a development container</h2><p>进入自己 fork 的 moby 项目 clone 目录，切换到某分支（如： <code>git checkout dry-run-test</code> ）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make BIND_DIR=. shell    # 该命令会构建一个名为docker-dev:dry-run-test 的镜像</span><br></pre></td></tr></tbody></table></figure><p>执行结果：（容器运行命令会打印在终端并运行，之后要执行复制保存即可）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Successfully built 87f31121696f</span><br><span class="line">Successfully tagged docker-dev:overlay-vxlan-port</span><br><span class="line">docker run --rm -i --privileged  -e DOCKER_CROSSPLATFORMS -e BUILD_APT_MIRROR -e BUILDFLAGS -e KEEPBUNDLE -e DOCKER_BUILD_ARGS -e DOCKER_BUILD_GOGC -e DOCKER_BUILD_OPTS -e DOCKER_BUILD_PKGS -e DOCKER_BUILDKIT -e DOCKER_BASH_COMPLETION_PATH -e DOCKER_CLI_PATH -e DOCKER_DEBUG -e DOCKER_EXPERIMENTAL -e DOCKER_GITCOMMIT -e DOCKER_GRAPHDRIVER -e DOCKER_LDFLAGS -e DOCKER_PORT -e DOCKER_REMAP_ROOT -e DOCKER_STORAGE_OPTS -eDOCKER_USERLANDPROXY -e DOCKERD_ARGS -e TEST_INTEGRATION_DIR -e TESTDIRS -e TESTFLAGS -e TIMEOUT -e HTTP_PROXY -e HTTPS_PROXY -e NO_PROXY -e http_proxy -e https_proxy -e no_proxy -e VERSION -e PLATFORM -e DEFAULT_PRODUCT_LICENSE -e PRODUCT -v "/home/atompi/GolandProjects/src/github.com/mission802/moby/.:/go/src/github.com/docker/docker/." -v "/home/atompi/GolandProjects/src/github.com/mission802/moby/.git:/go/src/github.com/docker/docker/.git" -v docker-dev-cache:/root/.cache    -t "docker-dev:overlay-vxlan-port" bash</span><br></pre></td></tr></tbody></table></figure><p>启动容器：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -i --privileged  -e DOCKER_CROSSPLATFORMS -e BUILD_APT_MIRROR -e BUILDFLAGS -e KEEPBUNDLE -e DOCKER_BUILD_ARGS -e DOCKER_BUILD_GOGC -e DOCKER_BUILD_OPTS -e DOCKER_BUILD_PKGS -e DOCKER_BUILDKIT -e DOCKER_BASH_COMPLETION_PATH -e DOCKER_CLI_PATH -e DOCKER_DEBUG -e DOCKER_EXPERIMENTAL -e DOCKER_GITCOMMIT -e DOCKER_GRAPHDRIVER -e DOCKER_LDFLAGS -e DOCKER_PORT -e DOCKER_REMAP_ROOT -e DOCKER_STORAGE_OPTS -eDOCKER_USERLANDPROXY -e DOCKERD_ARGS -e TEST_INTEGRATION_DIR -e TESTDIRS -e TESTFLAGS -e TIMEOUT -e HTTP_PROXY -e HTTPS_PROXY -e NO_PROXY -e http_proxy -e https_proxy -e no_proxy -e VERSION -e PLATFORM -e DEFAULT_PRODUCT_LICENSE -e PRODUCT -v "/home/atompi/GolandProjects/src/github.com/mission802/moby/.:/go/src/github.com/docker/docker/." -v "/home/atompi/GolandProjects/src/github.com/mission802/moby/.git:/go/src/github.com/docker/docker/.git" -v docker-dev-cache:/root/.cache    -t "docker-dev:overlay-vxlan-port" bash</span><br></pre></td></tr></tbody></table></figure><p>构建 <code>dockerd</code> 二进制文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hack/make.sh binary</span><br></pre></td></tr></tbody></table></figure><p>运行 <code>make install</code> ，将二进制文件复制到容器的 <code>/usr/local/bin/</code> 目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></tbody></table></figure><p>启动在后台运行的 Engine 守护程序</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd -D &</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-下载-moby-moby-源码&quot;&gt;&lt;a href=&quot;#0-下载-moby-moby-源码&quot; class=&quot;headerlink&quot; title=&quot;0. 下载 moby/moby 源码&quot;&gt;&lt;/a&gt;0. 下载 moby/moby 源码&lt;/h2&gt;&lt;p&gt;如果想要为 docker 贡献代码，则要进行以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Fork and clone the Moby code ： Fork 后 clone moby 源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set your signature and an upstream remote ：设置签名和上游 remote&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当你向 Docker 贡献代码时，你必须证明你同意（ &lt;a href=&quot;http://developercertificate.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Developer Certificate of Origin&lt;/a&gt; ）开发人员原产地证书。你通过签署你的 git 提交来表明您的同意，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Signed-off-by: Pat Smith &lt;pat.smith@email.com&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;具体做法：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.atompi.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.atompi.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS Ubuntu 离线源制作</title>
    <link href="https://blog.atompi.com/2018/12/20/Linux%E7%A6%BB%E7%BA%BF%E6%BA%90%E5%88%B6%E4%BD%9C/"/>
    <id>https://blog.atompi.com/2018/12/20/Linux%E7%A6%BB%E7%BA%BF%E6%BA%90%E5%88%B6%E4%BD%9C/</id>
    <published>2018-12-20T10:15:21.000Z</published>
    <updated>2021-02-23T13:43:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="制作离线-yum-源"><a href="#制作离线-yum-源" class="headerlink" title="制作离线 yum 源"></a>制作离线 yum 源</h2><p><strong>在可以连接外网的服务器上操作</strong></p><h3 id="修改源为ustc"><a href="#修改源为ustc" class="headerlink" title="修改源为ustc"></a>修改源为ustc</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">sudo vim /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># CentOS-Base.repo</span><br><span class="line">#</span><br><span class="line"># The mirror system uses the connecting IP address of the client and the</span><br><span class="line"># update status of each mirror to pick mirrors that are updated to and</span><br><span class="line"># geographically close to the client.  You should use this for CentOS updates</span><br><span class="line"># unless you are manually picking other mirrors.</span><br><span class="line">#</span><br><span class="line"># If the mirrorlist= does not work for you, as a fall back you can try the</span><br><span class="line"># remarked out baseurl= line instead.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#released updates</span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line"># mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=updates</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line"># mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=extras</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line"># mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=centosplus</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/centosplus/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></tbody></table></figure><h3 id="创建yum源安装包目录"><a href="#创建yum源安装包目录" class="headerlink" title="创建yum源安装包目录"></a>创建yum源安装包目录</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/yumcaches</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-createrepo-和-epel-release"><a href="#安装-createrepo-和-epel-release" class="headerlink" title="安装 createrepo 和 epel-release"></a>安装 <code>createrepo</code> 和 <code>epel-release</code></h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y createrepo</span><br><span class="line">sudo yum -y install epel-release</span><br></pre></td></tr></tbody></table></figure><h3 id="yumdownloader-下载相关repo包"><a href="#yumdownloader-下载相关repo包" class="headerlink" title="yumdownloader 下载相关repo包"></a><code>yumdownloader</code> 下载相关repo包</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/repodir</span><br><span class="line">yumdownloader docker mysql mysql-devel java-1.8.0-openjdk python python-devel python-pip MySQL-python python-docker-py unzip iptables curl iproute ufw vim postfix --resolve</span><br></pre></td></tr></tbody></table></figure><h3 id="createrepo-创建索引"><a href="#createrepo-创建索引" class="headerlink" title="createrepo 创建索引"></a><code>createrepo</code> 创建索引</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo -v /tmp/repodir/</span><br></pre></td></tr></tbody></table></figure><h2 id="制作离线apt源"><a href="#制作离线apt源" class="headerlink" title="制作离线apt源"></a>制作离线apt源</h2><p><strong>在可以连接外网的服务器上操作</strong></p><h3 id="修改源为阿里云"><a href="#修改源为阿里云" class="headerlink" title="修改源为阿里云"></a>修改源为阿里云</h3><p><code>vim /etc/apt/sources.list</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></tbody></table></figure><p><code>sudo apt-get update</code></p><h3 id="下载源安装包"><a href="#下载源安装包" class="headerlink" title="下载源安装包"></a>下载源安装包</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y dpkg-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get -d install openjdk-8-jdk libltdl7 mysql-client python python-dev python-pip python-mysqldb unzip iptables curl iproute ufw vim python-apt postfix</span><br></pre></td></tr></tbody></table></figure><h3 id="copy-var-cache-apt-archives-到-home-atompi-localpacks-下"><a href="#copy-var-cache-apt-archives-到-home-atompi-localpacks-下" class="headerlink" title="copy /var/cache/apt/archives/* 到 /home/atompi/localpacks/ 下"></a>copy <code>/var/cache/apt/archives/*</code> 到 <code>/home/atompi/localpacks/</code> 下</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/atompi/localpacks</span><br><span class="line"></span><br><span class="line">sudo cp -rf /var/cache/apt/archives/* /home/atompi/localpacks/</span><br></pre></td></tr></tbody></table></figure><h3 id="创建依赖索引"><a href="#创建依赖索引" class="headerlink" title="创建依赖索引"></a>创建依赖索引</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-scanpackages localpacks /dev/null | gzip > /home/atompi/localpacks/Packages.gz</span><br></pre></td></tr></tbody></table></figure><h3 id="copy-到目标机器"><a href="#copy-到目标机器" class="headerlink" title="copy 到目标机器"></a>copy 到目标机器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/atompi/localpacks atompi@192.168.1.131:/tmp/</span><br></pre></td></tr></tbody></table></figure><h3 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h3><p><code>sudo vi /etc/apt/sources.list</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb file:///tmp/ localpacks/</span><br></pre></td></tr></tbody></table></figure><p><code>sudo vi /etc/apt/apt.conf</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APT { Get { AllowUnauthenticated "1"; }; };</span><br></pre></td></tr></tbody></table></figure><h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><h2 id="制作-pip-源"><a href="#制作-pip-源" class="headerlink" title="制作 pip 源"></a>制作 pip 源</h2><p><strong>在可以连接外网的服务器上操作</strong></p><h3 id="安装python、python-dev、python-pip"><a href="#安装python、python-dev、python-pip" class="headerlink" title="安装python、python-dev、python-pip"></a>安装python、python-dev、python-pip</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y python python-dev python-pip</span><br></pre></td></tr></tbody></table></figure><h3 id="pip-安装-pip2pi"><a href="#pip-安装-pip2pi" class="headerlink" title="pip 安装 pip2pi"></a>pip 安装 pip2pi</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pip2pi</span><br></pre></td></tr></tbody></table></figure><h3 id="制作一个-requirements-txt-文件"><a href="#制作一个-requirements-txt-文件" class="headerlink" title="制作一个 requirements.txt 文件"></a>制作一个 <code>requirements.txt</code> 文件</h3><p><code>vim /home/atompi/requirements.txt</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-py</span><br></pre></td></tr></tbody></table></figure><h3 id="准备一个-packages-文件夹，作为存放本地源的路径"><a href="#准备一个-packages-文件夹，作为存放本地源的路径" class="headerlink" title="准备一个 packages 文件夹，作为存放本地源的路径"></a>准备一个 <code>packages</code> 文件夹，作为存放本地源的路径</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/atompi/pipackages</span><br></pre></td></tr></tbody></table></figure><h3 id="下载-pip-包"><a href="#下载-pip-包" class="headerlink" title="下载 pip 包"></a>下载 pip 包</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip2pi /home/atompi/pipackages --no-use-wheel -r requirements.txt</span><br></pre></td></tr></tbody></table></figure><h3 id="复制-packages-目录和-requirements-txt-文件到不能连接外网的目标机器上"><a href="#复制-packages-目录和-requirements-txt-文件到不能连接外网的目标机器上" class="headerlink" title="复制 packages 目录和 requirements.txt 文件到不能连接外网的目标机器上"></a>复制 <code>packages</code> 目录和 <code>requirements.txt</code> 文件到不能连接外网的目标机器上</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/atompi/pipackages atompi@192.168.1.131:/tmp/</span><br><span class="line">scp /home/atompi/requirements.txt atompi@192.168.1.131:/tmp/</span><br></pre></td></tr></tbody></table></figure><h3 id="开始离线安装"><a href="#开始离线安装" class="headerlink" title="开始离线安装"></a>开始离线安装</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-index --find-links=file:///tmp/pipackages/ -r /tmp/requirements.txt</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最后，需要在gitlab容器中激活git用户</span><br><span class="line"></span><br><span class="line">passwd git</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;制作离线-yum-源&quot;&gt;&lt;a href=&quot;#制作离线-yum-源&quot; class=&quot;headerlink&quot; title=&quot;制作离线 yum 源&quot;&gt;&lt;/a&gt;制作离线 yum 源&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在可以连接外网的服务器上操作&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改源为ustc&quot;&gt;&lt;a href=&quot;#修改源为ustc&quot; class=&quot;headerlink&quot; title=&quot;修改源为ustc&quot;&gt;&lt;/a&gt;修改源为ustc&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo vim /etc/yum.repos.d/CentOS-Base.repo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 各版本镜像列表</title>
    <link href="https://blog.atompi.com/2018/07/30/kubernetes%E5%90%84%E7%89%88%E6%9C%AC%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8/"/>
    <id>https://blog.atompi.com/2018/07/30/kubernetes%E5%90%84%E7%89%88%E6%9C%AC%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8/</id>
    <published>2018-07-30T14:32:21.000Z</published>
    <updated>2021-02-23T13:43:20.505Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下镜像列表由 kubeadm v1.11.1 导出，若使用预下载镜像离线部署的方式部署，请使用 kubeadm v1.11.1 版本</strong></p><p><strong>导出各版本镜像列表（需要科学上网）：</strong> </p><p><code>kubeadm config images list --kubernetes-version=v1.11.1</code></p><a id="more"></a><h2 id="插件镜像"><a href="#插件镜像" class="headerlink" title="插件镜像"></a>插件镜像</h2><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">quay.io/coreos/flannel:v0.10.0-amd64</span><br><span class="line">gcr.io/kubernetes-helm/tiller:v2.9.1</span><br><span class="line">k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">gcr.io/google_containers/heapster-amd64:v1.5.4</span><br><span class="line">gcr.io/google_containers/heapster-influxdb-amd64:v1.5.2</span><br><span class="line">gcr.io/google_containers/heapster-grafana-amd64:v5.0.4</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># flannel:v0.10.0-amd64 占位</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.9.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/heapster-amd64:v1.5.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/heapster-influxdb-amd64:v1.5.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/heapster-grafana-amd64:v5.0.4</span><br></pre></td></tr></tbody></table></figure><h2 id="核心镜像"><a href="#核心镜像" class="headerlink" title="核心镜像"></a>核心镜像</h2><h3 id="v1-10-0"><a href="#v1-10-0" class="headerlink" title="v1.10.0"></a>v1.10.0</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-10-1"><a href="#v1-10-1" class="headerlink" title="v1.10.1"></a>v1.10.1</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-10-2"><a href="#v1-10-2" class="headerlink" title="v1.10.2"></a>v1.10.2</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-10-3"><a href="#v1-10-3" class="headerlink" title="v1.10.3"></a>v1.10.3</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-10-4"><a href="#v1-10-4" class="headerlink" title="v1.10.4"></a>v1.10.4</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-10-5"><a href="#v1-10-5" class="headerlink" title="v1.10.5"></a>v1.10.5</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-10-6"><a href="#v1-10-6" class="headerlink" title="v1.10.6"></a>v1.10.6</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-11-0"><a href="#v1-11-0" class="headerlink" title="v1.11.0"></a>v1.11.0</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.2.18</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><h3 id="v1-11-1"><a href="#v1-11-1" class="headerlink" title="v1.11.1"></a>v1.11.1</h3><ul><li>官方镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><ul><li>阿里云镜像</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.2.18</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下镜像列表由 kubeadm v1.11.1 导出，若使用预下载镜像离线部署的方式部署，请使用 kubeadm v1.11.1 版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导出各版本镜像列表（需要科学上网）：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubeadm config images list --kubernetes-version=v1.11.1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://blog.atompi.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://blog.atompi.com/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="https://blog.atompi.com/tags/K8S/"/>
    
      <category term="docker" scheme="https://blog.atompi.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 Desktop 初始化</title>
    <link href="https://blog.atompi.com/2018/03/06/ubuntu16.04-desktop%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://blog.atompi.com/2018/03/06/ubuntu16.04-desktop%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2018-03-06T06:08:10.000Z</published>
    <updated>2021-02-23T13:43:20.505Z</updated>
    
    <content type="html"><![CDATA[<p>安装完 Ubuntu 16.04 Desktop 后执行以下命令，会让你得到一个干净、完整的开发环境。</p><a id="more"></a><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># 选择阿里云源</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade -y</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install shadowsocks-qt5 -y</span><br><span class="line">sudo apt install ssh</span><br><span class="line">sudo apt install python-pip</span><br><span class="line">sudo apt install curl</span><br><span class="line">sudo pip install genpac</span><br><span class="line">sudo apt install vim</span><br><span class="line">sudo apt-get install exfat-utils</span><br><span class="line"></span><br><span class="line">cd Documents/</span><br><span class="line">mkdir autoproxy</span><br><span class="line">cd autoproxy/</span><br><span class="line">vim ~/Documents/autoproxy/user-rules.txt</span><br><span class="line">vim ~/Documents/autoproxy/update.sh</span><br><span class="line"># 配置 shadowsocks-qt5</span><br><span class="line">cd ~/Documents/autoproxy/</span><br><span class="line">bash update.sh</span><br><span class="line"># 配置系统代理</span><br><span class="line"></span><br><span class="line">sudo apt-get install privoxy -y</span><br><span class="line">sudo mv /etc/privoxy/config /etc/privoxy/config.bak</span><br><span class="line">sudo vim /etc/privoxy/config</span><br><span class="line">sudo systemctl start privoxy</span><br><span class="line">sudo systemctl enable privoxy</span><br><span class="line">sudo vim /usr/local/bin/proxy</span><br><span class="line">sudo chmod +x /usr/local/bin/proxy</span><br><span class="line"></span><br><span class="line">sudo apt-get remove libreoffice*</span><br><span class="line">sudo apt-get remove unity-webapps-common</span><br><span class="line">sudo apt-get remove gnome-mahjongg gnome-sudoku gnome-mines</span><br><span class="line">sudo apt remove aisleriot</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br><span class="line"># 安装 jdk</span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/local/jdk1.8.0_152/bin/java 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/local/jdk1.8.0_152/bin/javac 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/jar jar /usr/local/jdk1.8.0_152/bin/jar 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javah javah /usr/local/jdk1.8.0_152/bin/javah 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javap javap /usr/local/jdk1.8.0_152/bin/javap 300</span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line">sudo apt install zsh</span><br><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo proxy apt install git</span><br><span class="line">sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br><span class="line">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  "registry-mirrors": ["https://gfty7g09.mirror.aliyuncs.com"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker</span><br><span class="line">sudo gpasswd -a ${USER} docker</span><br><span class="line"></span><br><span class="line">docker run -d -p 1337:1337 --restart=always --name=idealicsrv idealicsrv:1.0.0</span><br><span class="line">sudo apt-get install -y cmake build-essential libreadline6-dev libncurses5-dev</span><br><span class="line"></span><br><span class="line">docker pull redis:3.2.11</span><br><span class="line">docker pull mysql:5.7.21</span><br><span class="line">docker run -d -p 3306:3306 --name=mysql -e MYSQL_ROOT_PASSWORD=atompi123 mysql:5.7.21 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">docker run -d -p 6379:6379 --name=redis redis:3.2.11</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo add-apt-repository 'deb http://typora.io linux/'</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install typora</span><br><span class="line">sudo add-apt-repository -r 'deb http://typora.io linux/'</span><br><span class="line">sudo add-apt-repository -r 'ppa:hzwhuang/ss-qt5'</span><br><span class="line"></span><br><span class="line">anaconda3/bin/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">anaconda3/bin/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">anaconda3/bin/conda config --set show_channel_urls yes</span><br></pre></td></tr></tbody></table></figure><h2 id="Documents-autoproxy-user-rules-txt"><a href="#Documents-autoproxy-user-rules-txt" class="headerlink" title="~/Documents/autoproxy/user-rules.txt"></a>~/Documents/autoproxy/user-rules.txt</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">! 用户自定义规则语法:</span><br><span class="line">!</span><br><span class="line">!   与gfwlist相同，使用AdBlock Plus过滤规则( http://adblockplus.org/en/filters )</span><br><span class="line">!</span><br><span class="line">!     1. 通配符支持，如 *.example.com/* 实际书写时可省略*为 .example.com/</span><br><span class="line">!     2. 正则表达式支持，以\开始和结束， 如 \[\w]+:\/\/example.com\\</span><br><span class="line">!     3. 例外规则 @@，如 @@*.example.com/* 满足@@后规则的地址不使用代理</span><br><span class="line">!     4. 匹配地址开始和结尾 |，如 |http://example.com、example.com|分别表示以http://example.com开始和以example.com结束的地址</span><br><span class="line">!     5. || 标记，如 ||example.com 则http://example.com、https://example.com、ftp://example.com等地址均满足条件</span><br><span class="line">!     6. 注释 ! 如 ! Comment</span><br><span class="line">!</span><br><span class="line">!   配置自定义规则时需谨慎，尽量避免与gfwlist产生冲突，或将一些本不需要代理的网址添加到代理列表</span><br><span class="line">!</span><br><span class="line">!   规则优先级从高到底为: user-rule > user-rule-from > gfwlist</span><br><span class="line">!</span><br><span class="line">! Tip: </span><br><span class="line">!   如果生成的是PAC文件，用户定义规则先于gfwlist规则被处理</span><br><span class="line">!   因此可以在这里添加例外或常用网址规则，或能减少在访问这些网址进行查询的时间, 如下面的例子</span><br><span class="line">!</span><br><span class="line">!   但其它格式如wingy, dnsmasq则无此必要, 例外规则将被忽略, 所有规则将被排序</span><br><span class="line">! </span><br><span class="line"></span><br><span class="line">@@sina.com</span><br><span class="line">@@163.com</span><br><span class="line"></span><br><span class="line">twitter.com</span><br><span class="line">youtube.com</span><br><span class="line">||google.com</span><br><span class="line">||wikipedia.org</span><br></pre></td></tr></tbody></table></figure><h2 id="Documents-autoproxy-update-sh"><a href="#Documents-autoproxy-update-sh" class="headerlink" title="~/Documents/autoproxy/update.sh"></a>~/Documents/autoproxy/update.sh</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">genpac --pac-proxy "SOCKS5 127.0.0.1:1080" --gfwlist-proxy="SOCKS5 127.0.0.1:1080" --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output="autoproxy.pac" --user-rule-from="user-rules.txt"</span><br></pre></td></tr></tbody></table></figure><h2 id="etc-privoxy-config"><a href="#etc-privoxy-config" class="headerlink" title="/etc/privoxy/config"></a>/etc/privoxy/config</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 转发地址</span><br><span class="line">forward-socks5   /               127.0.0.1:1080 .</span><br><span class="line"># 监听地址</span><br><span class="line">listen-address  localhost:8118</span><br><span class="line"># local network do not use proxy</span><br><span class="line">forward         192.168.*.*/     .</span><br><span class="line">forward            10.*.*.*/     .</span><br><span class="line">forward           127.*.*.*/     .</span><br></pre></td></tr></tbody></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">http_proxy=http://127.0.0.1:8118 https_proxy=http://127.0.0.1:8118 $*</span><br></pre></td></tr></tbody></table></figure><h2 id="zshrc-alias"><a href="#zshrc-alias" class="headerlink" title="~/.zshrc alias"></a>~/.zshrc alias</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xinput set-prop $(xinput list|grep "AT Translated Set 2 keyboard"|awk '{print $7}'|cut -d '=' -f 2) "Device Enabled" 0</span><br><span class="line"></span><br><span class="line">alias mysql="docker run -it --rm mysql:5.7.21 mysql $@"</span><br><span class="line">alias redis-cli="docker run -it --rm redis:3.2.11 redis-cli $@"</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装完 Ubuntu 16.04 Desktop 后执行以下命令，会让你得到一个干净、完整的开发环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（64） -- iostat</title>
    <link href="https://blog.atompi.com/2018/03/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-64/"/>
    <id>https://blog.atompi.com/2018/03/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-64/</id>
    <published>2018-03-05T13:54:57.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>监视系统输入输出设备和CPU的使用情况</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>iostat命令</strong> 被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat (选项) (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c：仅显示CPU使用情况；</span><br><span class="line">-d：仅显示设备利用率；</span><br><span class="line">-k：显示状态以千字节每秒为单位，而不使用块每秒；</span><br><span class="line">-m：显示状态以兆字节每秒为单位；</span><br><span class="line">-p：仅显示块设备和所有被使用的其他分区的状态；</span><br><span class="line">-t：显示每个报告产生时的时间；</span><br><span class="line">-V：显示版号并退出；</span><br><span class="line">-x：显示扩展状态。</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>间隔时间：每次报告的间隔时间（秒）；</li><li>次数：显示报告的次数。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>用<code>iostat -x /dev/sda1</code>来观看磁盘I/O的详细情况：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iostat -x /dev/sda1 </span><br><span class="line">Linux 2.6.18-164.el5xen (localhost.localdomain)</span><br><span class="line">2010年03月26日  </span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait </span><br><span class="line">%steal   %idle  </span><br><span class="line">            0.11    0.02    0.18    0.35   </span><br><span class="line">0.03    99.31  </span><br><span class="line"></span><br><span class="line">Device:         tps   Blk_read/s    Blk_wrtn/s  </span><br><span class="line">Blk_read   Blk_wrtn  </span><br><span class="line">sda1                0.02          0.08       </span><br><span class="line">0.00          2014               4</span><br></pre></td></tr></tbody></table></figure><p>详细说明：第二行是系统信息和监测时间，第三行和第四行显示CPU使用情况（具体内容和mpstat命令相同）。这里主要关注后面I/O输出的信息，如下所示：</p><table><thead><tr><th>标示</th><th>说明</th></tr></thead><tbody><tr><td>Device</td><td>监测设备名称</td></tr><tr><td>rrqm/s</td><td>每秒需要读取需求的数量</td></tr><tr><td>wrqm/s</td><td>每秒需要写入需求的数量</td></tr><tr><td>r/s</td><td>每秒实际读取需求的数量</td></tr><tr><td>w/s</td><td>每秒实际写入需求的数量</td></tr><tr><td>rsec/s</td><td>每秒读取区段的数量</td></tr><tr><td>wsec/s</td><td>每秒写入区段的数量</td></tr><tr><td>rkB/s</td><td>每秒实际读取的大小，单位为KB</td></tr><tr><td>wkB/s</td><td>每秒实际写入的大小，单位为KB</td></tr><tr><td>avgrq-sz</td><td>需求的平均大小区段</td></tr><tr><td>avgqu-sz</td><td>需求的平均队列长度</td></tr><tr><td>await</td><td>等待I/O平均的时间（milliseconds）</td></tr><tr><td>svctm</td><td>I/O需求完成的平均时间</td></tr><tr><td>%util</td><td>被I/O需求消耗的CPU百分比</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监视系统输入输出设备和CPU的使用情况&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;iostat命令&lt;/strong&gt; 被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（63） -- yum</title>
    <link href="https://blog.atompi.com/2018/03/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-63/"/>
    <id>https://blog.atompi.com/2018/03/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-63/</id>
    <published>2018-03-04T13:23:31.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>基于RPM的软件包管理器</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>yum命令</strong> 是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum (选项) (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h：显示帮助信息；</span><br><span class="line">-y：对所有的提问都回答“yes”；</span><br><span class="line">-c：指定配置文件；</span><br><span class="line">-q：安静模式；</span><br><span class="line">-v：详细模式；</span><br><span class="line">-d：设置调试等级（0-10）；</span><br><span class="line">-e：设置错误等级（0-10）；</span><br><span class="line">-R：设置yum处理一个命令的最大等待时间；</span><br><span class="line">-C：完全从缓存中运行，而不去下载或者更新任何头文件。</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">install：安装rpm软件包；</span><br><span class="line">update：更新rpm软件包；</span><br><span class="line">check-update：检查是否有可用的更新rpm软件包；</span><br><span class="line">remove：删除指定的rpm软件包；</span><br><span class="line">list：显示软件包的信息；</span><br><span class="line">search：检查软件包的信息；</span><br><span class="line">info：显示指定的rpm软件包的描述信息和概要信息；</span><br><span class="line">clean：清理yum过期的缓存；</span><br><span class="line">shell：进入yum的shell提示符；</span><br><span class="line">resolvedep：显示rpm软件包的依赖关系；</span><br><span class="line">localinstall：安装本地的rpm软件包；</span><br><span class="line">localupdate：显示本地rpm软件包进行更新；</span><br><span class="line">deplist：显示rpm软件包的所有依赖关系。</span><br></pre></td></tr></tbody></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>部分常用的命令包括：</p><ul><li>自动搜索最快镜像插件：<code>yum install yum-fastestmirror</code></li><li>安装yum图形窗口插件：<code>yum install yumex</code></li><li>查看可能批量安装的列表：<code>yum grouplist</code></li></ul><p><strong>安装</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install              <span class="comment">#全部安装</span></span><br><span class="line">yum install package1     <span class="comment">#安装指定的安装包package1</span></span><br><span class="line">yum groupinsall group1   <span class="comment">#安装程序组group1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>更新和升级</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum update               <span class="comment">#全部更新</span></span><br><span class="line">yum update package1      <span class="comment">#更新指定程序包package1</span></span><br><span class="line">yum check-update         <span class="comment">#检查可更新的程序</span></span><br><span class="line">yum upgrade package1     <span class="comment">#升级指定程序包package1</span></span><br><span class="line">yum groupupdate group1   <span class="comment">#升级程序组group1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>查找和显示</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 MySQL 是否已安装</span></span><br><span class="line">yum list installed | grep mysql</span><br><span class="line">yum list installed mysql*</span><br><span class="line"></span><br><span class="line">yum info package1      <span class="comment">#显示安装包信息package1</span></span><br><span class="line">yum list               <span class="comment">#显示所有已经安装和可以安装的程序包</span></span><br><span class="line">yum list package1      <span class="comment">#显示指定程序包安装情况package1</span></span><br><span class="line">yum groupinfo group1   <span class="comment">#显示程序组group1信息yum search string 根据关键字string查找安装包</span></span><br></pre></td></tr></tbody></table></figure><p><strong>删除程序</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum remove &<span class="comment">#124; erase package1   #删除程序包package1</span></span><br><span class="line">yum groupremove group1             <span class="comment">#删除程序组group1</span></span><br><span class="line">yum deplist package1               <span class="comment">#查看程序package1依赖情况</span></span><br></pre></td></tr></tbody></table></figure><p><strong>清除缓存</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean packages       <span class="comment">#清除缓存目录下的软件包</span></span><br><span class="line">yum clean headers        <span class="comment">#清除缓存目录下的 headers</span></span><br><span class="line">yum clean oldheaders     <span class="comment">#清除缓存目录下旧的 headers</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于RPM的软件包管理器&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;yum命令&lt;/strong&gt; 是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。&lt;/p&gt;
&lt;p&gt;yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（62） -- apt-key</title>
    <link href="https://blog.atompi.com/2018/03/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-62/"/>
    <id>https://blog.atompi.com/2018/03/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-62/</id>
    <published>2018-03-03T14:32:52.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>管理Debian Linux系统中的软件包密钥</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>apt-key命令</strong> 用于管理Debian Linux系统中的软件包密钥。每个发布的deb包，都是通过密钥认证的，apt-key用来管理密钥。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>操作指令：APT密钥操作指令。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-key list          #列出已保存在系统中key。</span><br><span class="line">apt-key add keyname   #把下载的key添加到本地trusted数据库中。</span><br><span class="line">apt-key del keyname   #从本地trusted数据库删除key。</span><br><span class="line">apt-key update        #更新本地trusted数据库，删除过期没用的key。</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管理Debian Linux系统中的软件包密钥&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;apt-key命令&lt;/strong&gt; 用于管理Debian Linux系统中的软件包密钥。每个发布的deb包，都是通过密钥认证的，apt-key用来管理密钥。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（61） -- apt-get</title>
    <link href="https://blog.atompi.com/2018/03/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-61/"/>
    <id>https://blog.atompi.com/2018/03/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-61/</id>
    <published>2018-03-02T13:42:34.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>Debian Linux发行版中的APT软件包管理工具</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>apt-get命令</strong> 是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get (选项) (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-c：指定配置文件。</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>管理指令：对APT软件包的管理操作；</li><li>软件包：指定要操纵的软件包。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>使用apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb web或[ftp地址] [发行版名字] main/contrib/non-[free]</span><br></pre></td></tr></tbody></table></figure><p>我们常用的Ubuntu就是一个基于Debian的发行，我们使用apt-get命令获取这个列表，以下是我整理的常用命令：</p><p>在修改<code>/etc/apt/sources.list</code>或者<code>/etc/apt/preferences</code>之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></tbody></table></figure><p>安装一个新软件包：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install packagename</span><br></pre></td></tr></tbody></table></figure><p>卸载一个已安装的软件包（保留配置文件）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove packagename</span><br></pre></td></tr></tbody></table></figure><p>卸载一个已安装的软件包（删除配置文件）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get –purge remove packagename</span><br></pre></td></tr></tbody></table></figure><p>会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get autoclean apt</span><br></pre></td></tr></tbody></table></figure><p>这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get clean</span><br></pre></td></tr></tbody></table></figure><p>更新所有已安装的软件包：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></tbody></table></figure><p>将系统升级到新版本：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></tbody></table></figure><p>定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，您可以释放大量的磁盘空间。如果您的需求十分迫切，可以使用<code>apt-get clean</code>以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。大多数情况下您不会再用到这些.debs文件，因此如果您为磁盘空间不足 而感到焦头烂额，这个办法也许值得一试：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get autoclean</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Debian Linux发行版中的APT软件包管理工具&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;apt-get命令&lt;/strong&gt; 是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（60） -- ifup 、 ifdown</title>
    <link href="https://blog.atompi.com/2018/03/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-60/"/>
    <id>https://blog.atompi.com/2018/03/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-60/</id>
    <published>2018-03-01T13:12:32.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h2><p>激活指定的网络接口</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>ifup命令</strong> 用于激活指定的网络接口。</p><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup (参数)</span><br></pre></td></tr></tbody></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>网络接口：要激活的网络接口。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup eth0   #激活eth0</span><br></pre></td></tr></tbody></table></figure><h2 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a>ifdown</h2><p>禁用指定的网络接口</p><h3 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>ifdown命令</strong> 用于禁用指定的网络接口。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifdown (参数)</span><br></pre></td></tr></tbody></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>网络接口：要禁用的网络接口。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifdown eth0  #禁用eth0</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ifup&quot;&gt;&lt;a href=&quot;#ifup&quot; class=&quot;headerlink&quot; title=&quot;ifup&quot;&gt;&lt;/a&gt;ifup&lt;/h2&gt;&lt;p&gt;激活指定的网络接口&lt;/p&gt;
&lt;h3 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ifup命令&lt;/strong&gt; 用于激活指定的网络接口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（59） -- route</title>
    <link href="https://blog.atompi.com/2018/02/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-59/"/>
    <id>https://blog.atompi.com/2018/02/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-59/</id>
    <published>2018-02-28T13:41:28.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>显示并设置Linux中静态路由表</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>route命令</strong> 用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p><p>在Linux系统中设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的ip地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在<code>/etc/rc.local</code>中添加route命令来保证该路由设置永久有效。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route (选项) (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-A：设置地址类型；</span><br><span class="line">-C：打印将Linux核心的路由缓存；</span><br><span class="line">-v：详细信息模式；</span><br><span class="line">-n：不执行DNS反向查找，直接显示数字形式的IP地址；</span><br><span class="line">-e：netstat格式显示路由表；</span><br><span class="line">-net：到一个网络的路由表；</span><br><span class="line">-host：到一个主机的路由表。</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Add：增加指定的路由记录；</span><br><span class="line">Del：删除指定的路由记录；</span><br><span class="line">Target：目的网络或目的主机；</span><br><span class="line">gw：设置默认网关；</span><br><span class="line">mss：设置TCP的最大区块长度（MSS），单位MB；</span><br><span class="line">window：指定通过路由表的TCP连接的TCP窗口大小；</span><br><span class="line">dev：路由记录所表示的网络接口。</span><br></pre></td></tr></tbody></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>显示当前路由：</strong> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">112.124.12.0    *               255.255.252.0   U     0      0        0 eth1</span><br><span class="line">10.160.0.0      *               255.255.240.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">default         112.124.15.247  0.0.0.0         UG    0      0        0 eth1</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">112.124.12.0    0.0.0.0         255.255.252.0   U     0      0        0 eth1</span><br><span class="line">10.160.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">0.0.0.0         112.124.15.247  0.0.0.0         UG    0      0        0 eth1</span><br></pre></td></tr></tbody></table></figure><p>其中Flags为路由标志，标记当前网络节点的状态，Flags标志说明：</p><ul><li><p>U Up表示此路由当前为启动状态。</p></li><li><p>H Host，表示此网关为一主机。</p></li><li><p>G Gateway，表示此网关为一路由器。</p></li><li><p>R Reinstate Route，使用动态路由重新初始化的路由。</p></li><li><p>D Dynamically,此路由是动态性地写入。</p></li><li><p>M Modified，此路由是由路由守护程序或导向器动态修改。</p></li><li><p>! 表示此路由当前为关闭状态。</p><p><strong>添加网关/设置网关：</strong> </p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    #增加一条到达244.0.0.0的路由。</span><br></pre></td></tr></tbody></table></figure><p> <strong>屏蔽一条路由：</strong> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject     #增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。</span><br></pre></td></tr></tbody></table></figure><p> <strong>删除路由记录：</strong> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></tbody></table></figure><p> <strong>删除和添加设置默认网关：</strong> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route del default gw 192.168.120.240</span><br><span class="line">route add default gw 192.168.120.240</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;显示并设置Linux中静态路由表&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;route命令&lt;/strong&gt; 用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。&lt;/p&gt;
&lt;p&gt;在Linux系统中设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的ip地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在&lt;code&gt;/etc/rc.local&lt;/code&gt;中添加route命令来保证该路由设置永久有效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（58） -- dhclient</title>
    <link href="https://blog.atompi.com/2018/02/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-58/"/>
    <id>https://blog.atompi.com/2018/02/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-58/</id>
    <published>2018-02-27T12:33:45.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>动态获取或释放IP地址</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>dhclient命令</strong> 使用动态主机配置协议动态的配置网络接口的网络参数。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dhclient (选项) (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0：指定dhcp客户端监听的端口号；</span><br><span class="line">-d：总是以前台方式运行程序；</span><br><span class="line">-q：安静模式，不打印任何错误的提示信息；</span><br><span class="line">-r：释放ip地址。</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>网络接口：操作的网络接口。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dhclient -r     #释放IP</span><br><span class="line">dhclient        #获取IP</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态获取或释放IP地址&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;dhclient命令&lt;/strong&gt; 使用动态主机配置协议动态的配置网络接口的网络参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>每天一个 Linux 命令（57） -- dig</title>
    <link href="https://blog.atompi.com/2018/02/26/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-57/"/>
    <id>https://blog.atompi.com/2018/02/26/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-57/</id>
    <published>2018-02-26T13:23:24.000Z</published>
    <updated>2021-02-23T13:43:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>域名查询工具</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>dig命令</strong> 是常用的域名查询工具，可以用来测试域名系统工作是否正常。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig (选项) (参数)</span><br></pre></td></tr></tbody></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<服务器地址>：指定进行域名解析的域名服务器；</span><br><span class="line">-b<ip地址>：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；</span><br><span class="line">-f<文件名称>：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；</span><br><span class="line">-P：指定域名服务器所使用端口号；</span><br><span class="line">-t<类型>：指定要查询的DNS数据类型；</span><br><span class="line">-x<IP地址>：执行逆向域名查询；</span><br><span class="line">-4：使用IPv4；</span><br><span class="line">-6：使用IPv6；</span><br><span class="line">-h：显示指令帮助信息。</span><br></pre></td></tr></tbody></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>主机：指定要查询域名主机；</li><li>查询类型：指定DNS查询的类型；</li><li>查询类：指定查询DNS的class；</li><li>查询选项：指定查询选项。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dig www.jsdig.com</span><br><span class="line"></span><br><span class="line">; <<>> DiG 9.3.6-P1-RedHat-9.3.6-20.P1.el5_8.1 <<>> www.jsdig.com</span><br><span class="line">;; global options:  printcmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 2115</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.jsdig.com.               IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.jsdig.com.        0       IN      CNAME   host.1.jsdig.com.</span><br><span class="line">host.1.jsdig.com.     0       IN      A       100.42.212.8</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">jsdig.com.            8       IN      NS      f1g1ns2.dnspod.net.</span><br><span class="line">jsdig.com.            8       IN      NS      f1g1ns1.dnspod.net.</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 202.96.104.15#53(202.96.104.15)</span><br><span class="line">;; WHEN: Thu Dec 26 11:14:37 2013</span><br><span class="line">;; MSG SIZE  rcvd: 121</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;域名查询工具&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;dig命令&lt;/strong&gt; 是常用的域名查询工具，可以用来测试域名系统工作是否正常。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.atompi.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.atompi.com/tags/shell/"/>
    
  </entry>
  
</feed>
